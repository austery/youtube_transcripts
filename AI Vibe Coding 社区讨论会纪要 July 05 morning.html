<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vibe Coding 社区讨论会纪要</title>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <style>
        /* === 基础与布局 === */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f9f9f9; color: #333; }
        .report-container { display: flex; flex-direction: row; gap: 25px; max-width: 1200px; margin: 20px auto 0 auto; }

        /* === 元数据区块 === */
        .metadata-block { background-color: #eef2f7; border-left: 5px solid #007bff; padding: 15px 20px; margin-bottom: 25px; border-radius: 8px; font-size: 0.9em; max-width: 1200px; margin: 0 auto; }
        .metadata-block p { margin: 5px 0; color: #555; }
        .metadata-block strong { color: #333; margin-right: 8px; }
        .metadata-block a { color: #007bff; text-decoration: none; font-weight: bold; }
        .metadata-block a:hover { text-decoration: underline; }

        /* === 目录侧边栏 === */
        .sidebar-toc { flex: 0 0 250px; position: sticky; top: 20px; align-self: flex-start; max-height: 90vh; overflow-y: auto; padding: 15px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .sidebar-toc h3 { margin-top: 0; font-size: 1.1em; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .sidebar-toc ul { list-style: none; padding: 0; margin: 0; }
        .sidebar-toc li a { text-decoration: none; color: #007bff; display: block; padding: 8px 0; transition: color 0.2s; }
        .sidebar-toc li a:hover { color: #0056b3; }

        /* === 主内容区 === */
        .main-content { flex: 1; background-color: #fff; padding: 20px 30px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .main-content h1, .main-content h2, .main-content h3 { color: #2a2a2a; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; margin-top: 24px; margin-bottom: 16px; }
        .main-content h1 { font-size: 2em; }
        .main-content h2 { font-size: 1.5em; }
        .main-content h3 { font-size: 1.25em; }
        .main-content p { margin-bottom: 1em; }
        .main-content b { color: #0056b3; }

        /* === 响应式设计 === */
        @media (max-width: 768px) {
            .report-container { flex-direction: column; }
            .sidebar-toc { position: static; flex-basis: auto; width: 100%; max-height: none; box-sizing: border-box; }
        }
    </style>
</head>
<body>

    <div class="metadata-block">
        <p><strong>主持人:</strong> Dusing</p>
        <p><strong>嘉宾:</strong> Amy, Ray, Jay, Vincent</p>
        <p><strong>视频URL:</strong> <a href="[视频的完整链接]" target="_blank">观看原始视频</a></p>
    </div>

    <div class="report-container">
        <aside id="toc-container" class="sidebar-toc"></aside>
        <main id="content-body" class="main-content">
            <h1>AI Vibe Coding 社区讨论会纪要</h1>
            
            <h2>开场与社区未来展望</h2>
            <p><b>Dusing:</b> Amy，我邀请你了。Hello，好久不见，三个月没见到你了。</p>
            <p><b>Amy:</b> 对，我带着我的App来了。</p>
            <p><b>Dusing:</b> Ray，你要不要来聊聊？他跟我讲话。再看一下，是说再重新开一次那个直播吗？我改名字了。可是我现在看到的就已经是改完的了。对啊，我现在看到就是已经改完的。</p>
            <p><b>Dusing:</b> 截图一下。Amy，你的App做出来了吗？</p>
            <p><b>Amy:</b> 我做了一个大概，但是我还没有投入使用，但我觉得现在已经做到80%了吧。</p>
            <p><b>Dusing:</b> 感觉太牛了。</p>
            <p><b>Amy:</b> 但是很简单，我可能每天就花30分钟。因为我后来一开始想说是不是还要怎么美化它，但我发现美化这一方面AI也可以做。我这个人对于美化的重视程度是大于它实际使用功能的，所以我觉得还挺不错的，真的挺不错的。</p>
            <p><b>Dusing:</b> 嗨，Ray！嗨，Jay！早安，你那边应该很早。</p>
            <p><b>Ray:</b> 我刚刚五点，我四点半就醒了今天。哦，卡尔加里确实... Amy掉了，她又掉了，她的网络常常这样子。</p>
            <p><b>Jay:</b> 我特别好奇她是怎们考虑那些生命周期管理、移植期这些问题的。</p>
            <p><b>Dusing:</b> 你是说那个App的问题吗？对。OK，Ray，你有没有看到我们这个直播的名字？还是我要再重来一次？</p>
            <p><b>Ray:</b> OK，是正常的。</p>
            <p><b>Dusing:</b> 那就好了。我们大概还有两个人，我们等到五分。反正五分我们可以先跟Amy开始聊。Vincent来了，太好了。Ray，你要不要顺便来工商一下？虽然现在没有什么人让你工商。</p>

            <h3>社区发展蓝图：从共创到分润</h3>
            <p><b>Ray:</b> 我来工商一下。首先，邀请大家去加入我们的 Vibe Coding Space，这点很重要，我看好像咱们可能还都没有完全加进去。然后那个Space呢，我没有把它打开成每个人都能够自动进去，很重要一点是因为Vibe Coding（AI辅助编程：一种利用AI工具辅助进行软件开发的工作流）它是一个非常集中的话题，而且是一个会比较长期的话题。我们社区一直以来的理念就是，我们只做吸引，我们不做转化。所以说，只有你看到了，你感兴趣，你进来了，那就可以。</p>
            <p><b>Ray:</b> 这是第一个。第二个，咱们Vibe Coding将来它可能会成为一个新的东西，就是我们社群的下一步的一个大的升级计划。你看Dusing你们做的AI Program今天毕业了，到后面还会有其他各种Program。我发现很多Program做的都非常棒，它完全可以成为一个短期的付费Program。</p>
            <p><b>Ray:</b> 如果大家做得很棒，比如说Dusing可以搞一个这样的付费Program，那Amy也可以，Vincent也可以，Jay也可以。那未来就是我们社群的下一个大的Major Milestone（主要里程碑），就是跟我们的社区成员去分润。就是大家在这个平台上做得很好了，那我一口新范，现在咱频道名字也改成一口新范了，那就可以在频道里宣传说我们有这个Program，可以让外面人进来。</p>
            <p><b>Ray:</b> 那我们社群里的人想进到这个付费的Program，当然也可以，那就是要有折扣，那显然是有折扣。其实这是把两种不同的文化分开，是要分开的。这是我想了很久，其实Vincent知道我这个事情想了很久，这是两个不同的文化，因为我们社区内部是一个共创的文化，它不是一个交易的文化，所以我们要做这个事情是要非常小心的。这我琢磨了很久，所以我就想可以做这种短期的，就有点像Cohort（同期群组：指在同一时期开始学习或参与某个项目的一群人）的这种Program。</p>
            <p><b>Ray:</b> 像大家一样这种Program，那外人他只是对这个感兴趣，他可以来，短期地来了他走了，他实现他的目的。我们是一口新范的成员，是我们长期的成员，是我们文化的人，想进来那有折扣，那不想进来自己也可以搞共创的Program，对不对？我觉得这样会平衡好。所以下一个我觉得很重要的一个点，就是我们社区里大家自己搞得好的，如果愿意的话，我们一起来策划这些事情，然后我们打造几个咱们一口新范可以一直运行的这样的一个Program，可以对外，Dusing说的叫工商的，对外招商引资的。</p>
            <p><b>Ray:</b> 然后咱们一口新范就会迈向我一直以来的一个愿景，就是说它不是Ray的社群了，到了后面就是大家一起的社群。我觉得只有这样才可能真正迈向我原来想的那个Vision。所以就是为什么我跟Dusing说鼓励，因为我看大家做得真的很好，又是App又是分享各种东西的，我就应该公开搞一次毕业。第一呢，就是展示一下大家这么长时间的一个成果。第二也是给我们社区成员的Inspiration（启发），让大家能够参与到AI的Vibe Coding里面。然后第三我也就是想给各位一个邀请，你可以想一想我的Proposal，既然大家做得很好，已经走了这么一轮，有这个经验，其实为什么我们不去想办法去看看怎么开发，把它变成一个可以去收费的Program。</p>
            <p><b>Ray:</b> 那Vincent知道，我跟他分享过，其实我觉得我们任何合作，大家去分润的，就应该遵循一个公平的原则。我跟Vincent分享一本书叫《Slicing the Pie》（一种动态股权分配模型，根据贡献而非预先协商来分配初创公司股权），我觉得大家都可以看看。以后我们社区里的所有的，大家共创的、做这种盈利项目的时候，我们之间，比如说如果是Dusing跟Amy你们合作做的一个Program，那你们两个之间合作，你们之间怎么去分，对吧？怎么分就应该去按照这个。我觉得很重要，因为我创业这么多年，我很清楚这个理念是最重要的，其实不是其他的，反而是这个最重要。</p>
            <p><b>Ray:</b> 就是利益分配这一块。而且我是一个频道主，叫MoneySYZ，我就是一个搞钱的，所以我从来不避讳去公开谈这个事情。包括咱们社群未来的这一步我也不避讳，就是咱们社群，我一直就讲，我在社群里讲的话，就我跟社群的员工讲的话，跟大家讲的话，就是没有一句可以隐藏，都可以拿到明面上去讲的一个事情。公开的、透明的、诚实的、公平的，才是最powerful的东西。所以我就先简单工商到这里，非常感谢各位的这个Program，然后也希望大家进入到我们的Vibe Coding空间。</p>
            <p><b>Ray:</b> 然后我们在那里希望看我们将来在Vibe Coding上我们能不能出几个比较Specific的Program，因为Vibe Coding这个面太广了，不同的行业的人的用法是不一样的，每一个都可能是给自己的同行业或者说其他行业人带来不同的Inspiration。所以今天晚上我会有一个直播，当然大家有空的话欢迎来，欧洲就没戏了，Dusing就睡着了。下次了，好，那你们开始吧，感谢感谢。</p>
            <p><b>Dusing:</b> 好，谢谢Ray，谢谢。好，我们今天的流程是这样子，一开始就是因为Amy之前的主题我们一直没有机会跟她讨论，所以这一次是Amy的主题先开始。然后Thomas上次有定一个主题，我们第二个主题就是Thomas的。所以第二个主题是跟Prompt Engineering（提示工程：设计和优化给AI模型的输入文本，以获得期望输出的技巧）有关。然后第三个主题是Apple它最近发表了一篇论文，非常的有趣，对于我们做AI Coding或Vibe Coding非常的有帮助，然后这一篇论文我想特别跟大家分享。</p>

            <h2>议题一：Amy的AI辅助App开发实践</h2>
            <p><b>Dusing:</b> 好，那事不宜迟，我们就请Amy告诉我们你的update，你的进行进度，我们可以讨论一下。</p>
            <p><b>Amy:</b> 好，我先看一下怎么Share Screen。好，可以看到吗？我把这个窗口拉小一点。</p>
            <p><b>杜-兴:</b> 有看到，看到一个App。</p>
            
            <h3>从知识管理到菜谱App的构思</h3>
            <p><b>Amy:</b> 对，看到这个App。然后这个呢，我先说声抱歉，就是上两次因为各种原因没参加到，但是可能没有参加到，所以这次能展示一个稍微比较完整的App。然后呢，就是我先说一下整个心路历程好了。就是我们最早的时候是做那个AI Agent（AI代理：能自主感知环境、做决策并执行任务的智能程序）嘛。当时其实我是在Obsidian加Cursor（Cursor：一个专为AI编程设计的代码编辑器）去做了一个比较线性的管理，先是知识管理。但后来我发现可能光做文字的不是很有意思，因为我本来想用AI是做一些更酷炫的东西。</p>
            <p><b>Amy:</b> 然后当时我有一个问题，就是我觉得我可能每天不知道自己吃什么，或者说我有食材，但是我不知道要做什么。然后当时我就尝试用Obsidian（一个本地知识管理软件）去做了一个，比如说我拥有的一些东西，然后呢，根据我拥有的东西他再去生成一个菜谱。但他整个逻辑我觉得是比较线性的，就是你可能没有办法有一个互动，或者说你没有办法储存一些你自己的Data。所以当时我们就是进入到一个自由发挥的session了，我就想说是不是可以做一个App这样子。然后后来我才发现，OK，用Cursor去写处理文字工作跟做App是完全两个模式，然后用它去写Coding的话，我觉得是一整个让我真的大开眼界的一个状态。</p>

            <h3>App功能与实现展示</h3>
            <p><b>Amy:</b> 现在大概做了一个月，反正我陆陆续续做，就是我完全没有自己去写一行代码的情况下，就有了现在这样的一个App。然后我可以先给大家展示一下它能够做什么。首先，我整个逻辑就是首页的话，我会希望它先生成一个随机菜单。然后它这个所有菜单是会从我这个菜谱里面去随机生成两个早餐、两个午餐跟两个晚餐。然后你这边呢是可以自己加的，比如说我可能加一个test的菜谱，然后可能我这些加一些食材，比如说A食材，就这样吧，数量一个。然后这样的话你就可以生成一个自己的菜谱，然后呢，你会发现它在这边会有个test。然后你比如说我今天推荐菜单我不喜欢，然后我这样，你看它是会出现在这个地方的。所以它整个数据库是会从这个菜谱里面去抓出来，然后随机生成这样一个列表。</p>
            <p><b>Amy:</b> OK，那可能就是非常随机的，我生成了这样一个菜单。那我现在可以选择我早上想吃三明治，然后中午我吃这两个，然后晚上我可能只想吃这个。然后现在我就可以把它添加到我的这个菜单日历里面。然后这样的话，我可以选日期，我可能甚至不用把它添加在我今天的这个菜单。我想说明天我想吃这些，那我就选这个。那假设我们可能保存在今日菜单的话，你到这个菜单日历这个页面呢，你就可以... 怎么回事，怎么这么卷？有了有了。但是你看它会有一点bug。</p>
            <p><b>Amy:</b> 然后你看到这边它会显示我选用的这些菜单。然后它还有一个further function，就是你点击之后呢，它会跳到整个菜单，就是你要怎么做的一个食谱，就是一个这样的联动。你可以在这个菜单日历这边可以随机地去自己去手动的添加。你看这里有个bug，就是我不知道怎么回事，稍等一下。你看，这就是AI做Coding的一个弊端。</p>
            <p><b>Dusing:</b> Amy你有没有做那个Debugging（调试）或是做那个Unit Test（单元测试）？</p>
            <p><b>Amy:</b> 没有欸，我只是可能让它不断地去根据我的一些东西去修改这样子。它可能好像不太行，再来一次。好酷哦，先这样展示吧。对，然后，在我运行的时候还挺好的。哦对，可以了可以了。然后现在我就可以添加这个所谓的菜谱，就是这些，我可以直接给他加进去保存。那这样我比如说7号的周一，我早上就决定吃这个牛奶燕麦粥。然后如果说是有一些你可能叫了一个外卖，比如说小笼包，然后我就可以自定义添加。那它这个是不是从菜谱那个database里面出来的，所以你没有办法点击。它可能这个作用只是纯粹的一个记录，而不是一个计划的形式。我希望它这个页面是除了你能够计划你未来几天吃什么之外呢，你也可以自己自定义的去记录你所吃到的东西。就它的这个功能可能就分为计划跟记录这样两个大块。</p>
            <p><b>Amy:</b> 这就是一个菜单日历。然后这边呢，食材，就是之前我有一个痛点，就是我不知道我有什么食材，然后导致经常会浪费很多食物。那这样子的话呢，我基于这个痛点我就设计了这样一个配置。然后他的话呢，是可以比如说，我今天从超市买了一个白菜，然后它的分类可能是蔬菜，然后就是有这些种类。然后它可能保质期就九天，我可以把它设为到7月9号就到期。然后可能它是有三颗，这边你也可以选它的这个计量单位。我就点保存。那这样它就会出现在我的这个食材清单里面。然后呢，当然除了这个，你筛选的时候呢，它就会分门别类地出现。</p>
            <p><b>Amy:</b> 除此之外，比如说可能我买的是这个白菜，但是可能我的菜谱里面的话，它会含有一些这些食材。那我如果选择修改它这一个，OK，那我就知道，这个可能太少了，我用这个姜好了。然后一个，那这样我就知道OK，这个菜谱它是含这个食材的。其实它本来，我现在最新迭代那个版本出现bug了，所以没有办法显示，就是我可以根据它既定的菜谱，然后显示它所有的这个... 这样我就知道我现在拥有的食材是不是能够做成这道菜，大概是这样的一个概念。但这个版本可能没有更新，所以可能它现在只能显示说你有什么样的食材，然后你可以自己去自定义的添加，这是这样的一个页面设置。</p>
            <p><b>Amy:</b> 然后到菜单这边呢，就是这些是我让那个AI他去自定义生成的，然后你可以像我们刚才讲过，你可以自定义，比如说我们... 豆豉蒸排骨，这是我想吃的一道菜，它可以是午餐，可能烹饪时间很简单，因为它是一个预制菜，就可以选择非常简单的easy mode，这里不要预制菜。然后你可以给它添加，这样添加进去，然后它没有什么烹饪步骤，你可以不填，这样就可以保存下来。它就会出现在这个地方。那这样的话就等于说你有了这样一个数据，你再回到首页，下次你可能想换一个菜单的时候，它就会出现在这个地方，你就可以给它添加到你的这个菜单里面。大概就是这样子的一个流程。所以基本上这个App的话是能够满足我个人在日常自己做饭的时候的一个记录包括计划的一个需求。对，虽然还不是非常非常的完美，但是我觉得基本上已经能够达到我想要的一个目的了。</p>
            
            <h3>AI在UI设计与调试中的应用</h3>
            <p><b>Amy:</b> 然后我当时想的是做一个好看的App，就可能现在这个基准的话，是我已经做出来一个App了。但是后来我发现，可能本来我需要做一个logo，比如说像这个logo的话，我都可以让AI去帮我生成。可以看到吗？这个AI相关，然后这个App的logo，我给大家看一下，这个“What to Eat”这个小logo其实也是我用AI三秒钟生成的。你看，就是这样，我让它做一个cooking的一个icon，它就帮我生成了这样几个。</p>
            <p><b>Amy:</b> 我会在Cursor里面去问他怎么样能够帮我替换成这个App的icon，同时我希望他在主页这边显示，他都可以帮我做到。甚至比如说有的时候我会觉得这个装饰性的图片它有点太靠上了，我就跟Cursor说，你帮我往下一点，然后他就可以这样帮我去纯粹地用文字就可以指挥把它变上变下这样子。所以我觉得不光是做一个App，它可以实现帮你达成一个好看的App的这样的一个目的。包括像它其中提到的这些，你可以看到整个App他的这个色系啊，然后色调，就是我直接跟大家说，我说我想要一个你色系的App。然后如果说有单独的这个icon或者说什么一些这种小的icon都是可以让AI帮我去增加的。所以我觉得这个真的是，就除了功能之外，它的颜值也很容易就能达到一个我很理想的状态。</p>
            <p><b>Amy:</b> 这个就是我的一个分享。然后可以给大家看一下我的整个coding，就是你可以看到我给他的这个提示的话，会非常非常非常简单。就假设我们可以举一个非常简单的例子吧，比如说我现在run这个Xcode（苹果官方的集成开发环境），它会有一个问题吗？然后呢，就非常简单，然后你就copy这个它报错的地方，你可以看到它是在这个Home View这个文档里面出现了问题。你只要去这个地方，你找到185行，然后你给它这样子，add to chat，然后跟它说这里报错。然后他就会帮你去进行修改。所以所有的所有的问题也好，你要进行的修改也好，就直接通过这个对话框他就可以帮你修改。然后你只要出现了这个勾勾，你就可以应用它，然后他就会帮你全部修改。就是这么简单，就是我一点coding都没有做，然后一点design都没有做，然后他就帮我生成了这样一个App。所以我觉得真的就是大家现在都可以尝试一下用Cursor去做一个自己的工具。就我觉得如果你要面向所有人去上架这个App的话，可能还是需要一点点进一步的知识，但是如果你想要给自己打造一个工具的话，完全用Cursor加上这个Xcode就可以达到了。我的分享就是大概这样子。</p>

            <h2>议题二：AI辅助开发的经验与挑战</h2>
            <p><b>Dusing:</b> Amy，我有一个问题，你真的有把这个App安装到你自己的手机里面用吗？</p>
            <p><b>Amy:</b> 投入使用还没有，但是我已经把它放到我的手机App上面去了。因为它这个Xcode，你是可以直接连到手机上去看预览的，因为我觉得在手机上看会比较方便。我有用它去记录我的一些食材，但是真正生成菜单的话，还没有实际的使用。</p>
            <p><b>Dusing:</b> 我一开始看你做，我以为你真的是要放在App Store，所以其实你只是自己用而已。</p>
            <p><b>Amy:</b> 我先Stop sharing。我其实有想把它上架，因为我看到我们那个群友Serena她上架了，也是上架了一个好像有点类似于食谱的一个App吧。但是我觉得想把它做的再完美一点，再完美一点。</p>
            <p><b>Dusing:</b> 期待看到你登上App Store的一天。那你中间有没有遇到什么困难，或是你觉得很难解决，到现在还是觉得很难解决的？</p>
            <p><b>Amy:</b> 我觉得如果只是仅限于打造一个App作为自己的工具的话，完全没有。然后我甚至还搞了很多那种小的App，就比如说，我想搞一个那种可以记录我做一个任务到底花费了多少时间。比如说有的时候我剪一个视频，我会觉得自己好像花了很长时间，但实际上我不知道他投入多少。然后我就可能自己做一个小工具，就是比如说我的这个任务是什么，然后我给他从任务开始，然后我就按这个start，就是一个计时，然后他最后会帮我统计出来每个任务大概花了多少时间。我觉得他有点像人类开始从那个钻木取火，然后自己发明工具的那个阶段，但是是一个现代版本的一个进化，我觉得还蛮有意思的。</p>

            <h3>不同AI工具的比较：Cursor vs. Claude Code</h3>
            <p><b>Ray:</b> 我能分享一个吗？这就是为什么大家一定要去那个Vibe Coding的Space。就是我们在Vibe Coding的时候，你看现在大家都在搞AI，其实我们有很多是unknown，就我们不知道我们不知道的。比如说像Amy刚刚用Cursor，我其实我到现在都没有碰过Cursor的。然后我自己做那个Mac上的App呢，我用的是Claude Code（Anthropic公司推出的AI编程助手）。然后很多人会觉得Claude Code是给懂代码的人，但其实不是。Claude Code它是在命令行里面，在terminal里头，你会觉得是那个你必须得懂代码才行，那个界面根本就感觉很不友好。但其实不是，它比Cursor要好用的太多了。Amy可以试一试，然后你在Claude Code里头可以加mcp，它可以控制Xcode，它能够去打开Xcode去给你做测试，点那个按钮，然后在你手机上去点点点，有问题它自己改。像你刚才你copy-paste的这个都完全都不需要做了，你就只需要一个总设计师的一个概念。</p>
            <p><b>Ray:</b> 你在指挥他，但是有时候你需要去推测哪里出现问题了，然后让他去做。甚至Claude Code都可以开启一个不需要你say yes的模式，就是让他自己完全自己执行，然后你就睡觉就好了，第二天早上起来你再去看，都是可以的。</p>

            <h3>前端开发的简易性与后端逻辑的复杂性</h3>
            <p><b>Dusing:</b> 非常非常有趣。所以我今天晚上直播在亚洲的有时间可以来一听听大家的分享，你们也可以向Amy一样分享。好，我工商到这里，请大家继续。谢谢Ray。我想要echo（附议）一下Amy讲前端的部分。就是我跟咏蓉现在在做一个App，然后我们其实也是发现其实前端是最简单的。我可以给大家看一下我的设计稿跟实际的App长什么样子。但因为有一些我们还在开发这个App，所以我们里面的逻辑我就暂时先不跟大家分享。但就是可以跟大家看那个实际上长什么样子，因为你会发现就是Cursor它其实还蛮会，像我是用Cursor，Cursor其实还蛮会写前端的东西的，很快就写出来。</p>
            <p><b>Dusing:</b> 然后我有用过那个MCP去连我的设计稿，可是后来发现连这样子的步骤都不用，我直接把截图给它就好了。好，我现在来分享一下。就是给大家看，这是我在Figma（一个基于浏览器的协作式UI设计工具）上面画的稿，Figma是一个网页的设计工具，那我就只是有点像是用Illustrator把它画出来而已。然后这个画出来我就把它截图直接喂给Cursor，然后这是Cursor后来做出来的成品，我是架在Vercel（一个面向前端开发者的云平台，提供部署和托管服务）上面。出来的成品就是长这样，其实跟这个没有差很多。然后我我又叫Cursor把一些把这个黄色给拿掉，所以现在是白色。然后像现在你现在看到所有的这些Effect通通都是Cursor写的。</p>
            <p><b>Dusing:</b> 所以其实如果Cursor它不管其他的dependency（依赖项），比如说我不去管数据库，我不去管产品生命周期，我不去管Cybersecurity（网络安全），什么都不管，如果只剩一个皮，它是非常快的，然后它很快就可以给一个界面。然后当你真的就是像Amy讲，如果你真的这个产品，因为我们这个产品是要是真的是要拿去上架，拿去卖的，那真的产品的话，你真的就是要去深入研究前端跟后端的技术，然后还有数据库，跟甚至是到最后上架之前你要去研究一下Cybersecurity。顺便展示一下。</p>

            <h3>从想法到产品的鸿沟：明确需求的重要性</h3>
            <p><b>咏蓉(Vincent):</b> 谢谢独行，不好意思大家，我来晚了。但是就是刚才独行说到这个事情，而且我也看了那个Amy的那个展示，我可能我这边分享一点我自己的感受。就是说我和独行我们俩现在在尝试去做的这个软件呢，相当于是我之前工作的一部分，然后这一部分的工作呢，是我觉得特别花时间，然后特别的无聊，特别枯燥的。所以我们当时就想，我们是不是可以做这么一个软件，然后把它做出来取代它。</p>
            <p><b>咏蓉(Vincent):</b> 然后我最大的感受就是说，其实现在的大语言模型，它已经，它的基础的能力已经够了。最大的瓶颈，像我们开发这个产品，如果让它最终能够提供价值，可能对我们来说最大的瓶颈除了开发一些技术方面的细节以外，最大的瓶颈是怎么能把我们的这个需求，我们想要的结果很好、很明确的去描述给GPT或者说这个大语言模型。这个可能是我觉得我们中间遇到了最难的地方。因为之前我做这一部分的工作的时候，很多时候是想当然的，就是我大脑里的一些步骤，一些这种decision tree（决策树），我可能自己是没有觉知的。我是说，我看到这个文件，看到这个任务，我就自然而然知道去怎么去执行它。</p>
            <p><b>咏蓉(Vincent):</b> 那现在我们如果要喂给这个大语言模型，我们是要把所有的步骤从相当于从这个大脑里面全都搬出来，然后一点一点把它细化。然后本来我以为可能是两三步就可以完成的事情，但是到现在我们开发到现在的话，会发现OK，整个的大脑里面去处理的这个流程，最终我们可能分成了大概三百到四百步左右。但是把这三百步、四百步全都分出来之后，再喂给大语言模型，它就完全可以做到和一个普通的人，一个受过训练的这个人，他去做这个事情，基本上是一模一样，甚至说更好的效果。对，所以说我的这个感受就是，OK，其实有的时候现在这个限制可能不是说AI或者说这个大语言模型它的能力，可能限制是人自己本身对这个任务的理解，或者说怎么样把脑子里的信息搬出来的这个能力。对，好，谢谢。</p>
            <p><b>Amy:</b> 我觉得咏蓉他说的时候，我突然就想到我当时做这个App过程中的痛点。就是为什么刚刚Dusing问我有没有用，是因为每次用都会有bug，然后用了之后你就会发现它有问题，然后你有问题的时候你再去迭代，然后你这个时候你再去修改的时候你会发现第二个问题。所以就是我觉得它整个你要搭一个框架很快，但是你要做的是不断的不断的给它完善。我觉得这个过程还是漫漫长的，就直到它达到一个完美状态前，需要经过很多很多很多很多修改。是的，是的。</p>

            <h3>软件开发的本质：迭代与流程</h3>
            <p><b>咏蓉(Vincent):</b> 我本来也觉得说可能有了AI之后很快Vibe Coding就把这个东西可以做出来，但是发现其实和我想象的完全不一样，就像Amy说要迭代好多次，然后中间我可能也很沮丧，Dusing是劝了我好多次说开发软件可能就是要有这么多的迭代，这么多的cycle，后来我才明白理解。</p>
            <p><b>Dusing:</b> 我是本科生嘛，然后我又在软件公司上班，所以我很清楚就是Vibe Coding它在怎么样帮助你，但是你还是，真正你要用的产品，你还是得要经过软件开发的流程。因为软件开发它不是，它不是只是在coding，它其实有很多Mindset是帮你把这个软件变好。所以我其实一开始，我们一开始在开发的时候，我是跑去再回去看一下，思考一下我们流程要怎么做，然后再去看一下软件开发流程有关的资料跟书籍，然后想一下说怎么做会比较好。然后我们因为我们是只有两个人的Startup，那我们做到什么程度就好了，不用像大公司，不用像Amazon那样做到那么齐，这样之类的。所以一开始其实是在想这个，就是没有马上就泡进去Vibe Coding，而是先去想怎么样流程会出来好的产品。</p>
            
            <h3>简单需求的力量：“小猫补光灯”案例</h3>
            <p><b>Amy:</b> 但是我还想分享一个小的案例，就是我觉得，我不知道可能大家听了觉得做App是一个很复杂的东西，但是我觉得那个初始的idea非常重要。就是国内他有一个很简单很简单的一个App叫“小猫补光灯”，我不知道大家有没有听过？没有听过啊，OK。它是什么样一个App呢？就是极其简单，就是他只是你打开这个App之后，他会有这样的一个，就是一块色板，就是一个色板。但是他解决的什么问题？就是女生有的时候拍照，她会觉得不够亮，但是如果你手机屏幕上显示了一个白色的底板，或者说一个粉色底板，就能改变这个拍照的那个色调。然后所以就是这样一个简单的App，它赚了16万。然后还在国内非常非常的火，因为它解决了很多女生自拍的时候光不够的那个痛点，但是它又不需要一个补光灯，它做的只是在这个打开App之后放上了一个纯色的底板。所以我觉得就是这个idea它非常非常的简单，但是它靠这个，它也是用Cursor做的，然后赚了很多很多的钱。所以我觉得如果一个不一定要有很复杂的App，然后你用一个很新颖的idea，加上很简单的AI coding的话，也能实现这个变现。</p>
            <p><b>Dusing:</b> 真的，我也觉得需求分析，就是那个customer needs是最重要的。所以我觉得真的要花很多时间去调查说到底使用者他需要什么。然后你只要，我觉得产品的部分只要确保它不会一直用到一半一直crash就好了。我觉得至少可以先满足这个，然后还有就是比如说不要被黑客攻击之类的。我觉得至少这几本先满足就好了，然后你就可以开始赚钱了。怎么被我们讲得好像邪教一样。好，那Amy你还有没有什么问题？如果没有的话，我们可以进行下一个主题。</p>

            <h3>技术探讨：数据库、版本管理与随机算法</h3>
            <p><b>Jay:</b> 我很好奇你是怎么搞定那个数据库那个环节？因为当时那个环节我卡的非常惨，而且也是那个环节导致我最后决定会去重新读读书，而不是去改。就是我当时卡在数据库，但是其实真正不是问题是数据库，真正问题是我不懂生命周期的管理，然后导致出现很蠢的bug。然后我发现我是，然后导致我就准备回去重新读一读类似于这种编程类的教科书，去学一下这些基础。然后我发现那是Cursor没办法帮助我的。但是我看到Amy那个App里面，她其实把所有数据库什么都做得挺好的。所以我还挺想知道你中间有没有比如说，出现某些生命周期管理的问题。</p>
            <p><b>Amy:</b> 我觉得第一可能是因为我这个数据库量不是很大，然后第二就是他这个数据库也很简单。因为我其实涉及到的数据库就是一个菜单嘛，就是既有的这个菜单。我可以给大家分享这个Xcode里面，它其实有一个叫preset recipe，它这个里面其实就是我的那些菜单。然后如果说这个应该是最新的那个版本，就是你可以看到如果说我在这个地方增加一些数据，比如说增加一个新的菜谱的话，它是会同步到这个preset recipe里面的。然后我一直就比如说，因为有的时候可能我们看一些小红书，我看到一个好吃的菜，然后我就想把它加在这里，它就可以放到这里。然后我可能做的一个让Cursor做的联动，就是把这边的这个生成的东西是由这个数据库去引出来的。所以其实就非常简单，我觉得没有涉及到一些你说的那些什么生命周期的问题。</p>
            <p><b>Dusing:</b> 我知道为什么Amy没有这个问题，因为Amy直接用了一个Framework（框架），然后我刚刚仔细看她的档案架构，她那个Framework已经帮她把数据库的部分已经先设定好了。所以她只要去跟Cursor讲指令，Cursor就自动会帮她执行数据库的创建跟管理。我们也是类似，就是我们也是用一个framework，只是说因为我们是用web程式，我是用后端的程式。那就是我觉得现在就是你要去省那个时间，你就是要想办法去找一个你觉得适合的framework，然后不要说就是全部通通都自己弄。然后我在做这件事情的时候，我也发现一件事情，其实找framework，你有一个framework会比较好一点。因为无论是Cursor还是什么，就是大语言模型它里面它就是去搜集大家网路上的资料。然后就是因为这些framework它如果行之有年，那它会有大量的资料在网路上，那Cursor就会有范例可以看，知道怎么写。那如果说你是很新的framework的话，你就变成说你要贴文件给它。</p>
            <p><b>Dusing:</b> 所以我们数据库的管理，Amy那边我看到的是说它是直接用到那个Framework管理。我这边的管理方式我有分两个部分。我首先我在测试，我一开始还在产品很雏形的时候，我的资料通通存在浏览器，这是开发Web程式的优势，就是你的资料可以通通存在浏览器。可是接下来我就要去思考说，OK，我不可能就是让用户的资料全部只存在浏览器，我还是要存在我的remote，那我就是要去找相关的服务，就是可以让你存后端数据库的服务，然后最好是越简单越好用越好。所以我如果是这个数据库的部分的话，我觉得就是分两个层次，就是一个要先简化它，越简单越好，然后使用framework这样子。</p>
            <p><b>Jay:</b> 我还有一个问题，Amy你是怎么解决这种随机生成菜单这个功能的？是用GPT的什么API吗？</p>
            <p><b>Amy:</b> 我就是让它帮我随机生成两个早餐、两个午餐跟两个晚餐。</p>
            <p><b>Dusing:</b> Amy，你知道你的那个random的那个认算法是什么吗？它是直接认数吗？还是说它有一个，你有给它一个逻辑？</p>
            <p><b>Amy:</b> 我没有，因为我其实没有涉及任何coding，因为我只是说，OK，我就像一个产品经理在压榨这个工程师，我就说我想要这个什么，然后我说这个做的太丑了，帮我改一下。就是就非常简单，任何人都能听懂的语言。所以其实他背后的逻辑我不知道，但是我只知道他有没有达成我想要的效果，如果没有的话我就跟他说你没有达成，然后帮我再重新。因为其实我想要的他这个随机的功能，就是也不需要他有什么非常... 我就是个食谱菜单，我还要他怎么个随机。就他只要随机帮我出现我数据库里面的那些内容就可以了。</p>
            <p><b>Jay:</b> 那他每次都会，他随机的结果会是你满意的吗？还是真的就是很random？</p>
            <p><b>Amy:</b> 因为其实我只想要一个开始的页面，然后他可能，因为我后面其实有加功能，是他可以自定义，就是我自己去选择我想要的菜谱。所以他这个可能只是帮我，怎么说，就先给我一个三餐，然后呢我可能自己再想吃别的我在家。就等于他提供一个基础，然后我是可以自定义再去做的。所以他这个随机生成的内容不是特别重要，对我来说。</p>
            <p><b>Dusing:</b> 我猜啦，我现在猜，就是猜他应该就做两件事，第一个就是他不要出现错误。这是他第一个逻辑。然后第二个逻辑，他应该就是从现有的菜随便再挑一个。然后他应该就是给你一个乱数，因为我猜应该是你们每一个菜你都有一个ID，他就是直接给你一个乱数这样子。其实你可以直接问他呀，直接问Cursor，你的逻辑是什么呀，你给我解释一下呀。</p>
            <p><b>Ray:</b> 对吧，刚才Jay说的特别有意思，你看，就我觉得大家的conversation特别有意思啊。因为跟我，我们是属于是不知道Dusing你在讲什么生命周期啊什么的，对啊，我好假装听得懂的样子，就是不知道你在讲什么。然后呢，你们呢，就是科班出身的。我不是说这个是谁有好谁坏。这个为什么大家要有这个conversation，你去对话你会发现，真的我觉得从每个人身上都能学到特别valuable的东西。你就是从Amy身上咱们学到，你应该成为一个很明确的产品经理，你要去压榨他。就是你怎么去压榨AI，这是一门学问，真的，你怎么去压榨，你怎么去跟他讲，让你解决问题，帮你实现，怎么去push他。就跟我跟那个Claude Code，有时候我push他，有时候我就哄他。真的，有时候我说你怎么就那么轻易放弃呢，你仔细好好反思一下。然后他自己啊就反思，哎呀我自以为是了，我怎么样。然后再做好，我说哎呀你这么太棒了，然后你这个真的是太好了等等等等。</p>
            <p><b>Ray:</b> 就像刚才Jay他问Amy的问题，他这可能想就是那个是不是比如说有这个菜，让GPT自动它给你就生成菜谱或怎么样。然后Amy呢可能是有一个，我我刚才没有听清，是pre-defined的一个菜谱还是怎么样，他自己随机。所以不知道，所以其实你可以去问问cursor是怎么弄的。你也可以加入这个AI的这个功能啊，你想再尝试调用其他API吗？就你都，我冰箱里有这个东西，你自己给我creative的，你给我弄一个菜谱，对吧？天天AI给你做菜，这位挺好玩的嘛。所以你看就好多思路，就是为啥大家一定得聊。这是我发现的，就是懂编程的人能从不懂编程的人能学到他很多更上层的一个思维，其实就更设计层面思维。因为你不懂编程人他必须得只从上层思维来指挥AI。但懂编程人那容易钻进去，但是不懂编程人他就需要从懂编程人那学会语言。就我得知道我不知道什么。你比如说刚才那个Dusing说那个versal，对吧，是host在versal上，这玩意我原来不知道是啥玩意啊。是我前两天vibe code，我们那个社群的那个这个月的读书问题，我的vibe coding那个时候我想解决一个问题，我就问AI，他说哎你可以这么这么这么这么这么这么，有这几个困难，你可以用... 我啥是versal，啥是Cloudflare，老听说这个名，他这个到底干啥？我说你给我讲讲呗。然后你看这也是一个学习的过程。所以其实这就是一个相互学习的一个过程，我觉得非常好。就为什么大家在一起啊，就是能进步的很快。对。Amy就是一个非常bossy的产品经理。</p>
            <p><b>Dusing:</b> 对啊，其实的确是，就直接问他就好。我我也是這樣子，我我通常他寫完我會去問說，你你你剛剛用了什麼方法，做了什麼事情。然後我會做一件事就是說，OK，我我還是想要去理解他大概怎麼做這件事情，因為萬一如果以後我在增加功能的話，我不希望那個功能在打架，所以我會跟他講說，請你告訴我你在這邊你用了什麼方法，就是用口語的方式，然後我請他寫個文件給我。我在Cursor是有好幾份這樣子的文件，就是他這個功能他是做了什麼。譬如說我就會，我是Amy的話我就會跟他講說，那請問你的random，你的隨機你是怎麼做的？然後有沒有是你就是亂數嗎？还是你有没有依据我的偏好之类的？</p>
            <p><b>Dusing:</b> 然后你就可以想说，OK，那我下一次我那个推荐我就不要完全是random，我可能可以改善一下，让他可以依据我之前的偏好，比如说我不爱吃胡萝卜，胡萝卜就不要再出现了之类的。我在乱讲的。</p>
            <p><b>Jay:</b> 我其实很好奇一个问题，因为之前Amy她这个App设计的初衷是想在冰箱里面根据剩余食物做一份，让GPT生成一个菜单，所以我才想问的就是最后这个功能是由GPT实现的吧？然后除此之外我还有一个很好奇的问题是，就是这个问题是我自己真实遇到的。我最开始的时候我是不知道有GitHub和Git这个东西的，就是我完全不会用这些玩意。然后我发现好家伙，版本管理这种失败，然后以至于我那个，我最新的，我上次迭代那个版本的那个App里面，它现在是属于一个bug，但是我改不回去。由于没做版本管理，我不知道你用过这个经历，就是版本管理的问题有没有出现过？Cursor给你改到哪个版本，然后发现哎呀，退不回上上两个版本了，就是想回去但也回不去。你有做版本管理吗？</p>
            <p><b>Amy:</b> 没有做那个git，然后我只会跟Cursor说，我说这个修改的不好看，帮我恢复成上一个版本，他就会帮我那个，比如说他修改的code再还原这样子。如果出现了bug，然后我就会跟他说那个第几行报错，你帮我改，就是这么笨的办法。</p>
            <p><b>Ray:</b> 我分享一下Git这个，我觉得特别有意思。就是这就是我们Vibe Coding你一定会知道的问题。其实虽然我们没有听说过Git，你做到一定程度，你自己就会有版本管理的想法。我这个好不容易这个东西工作，你别再给我改坏了。我就会手动的再把这个东西再存一份。然后后来我就想，好像有个东西叫Git。然后很有意思，我在Claude Code里头我就说，我原来从来不用Git，Git是干啥的你知道吗？然后我大概知道它是版本管理，但我不知道怎么用。我跟Claude Code说，我说你给我管这个吧，你怎么用Git，你给我去该push push，该commit commit。我昨天我还没弄明白什么叫PR，我说啥PR，Public Relation吗？我说你干嘛要PR？这个然后那个什么pull request什么之类whatever。但是在Claude Code里面就是，基本上我说我不懂，你告诉我怎么弄，你就告诉我我做啥，我给你啥，剩下你全管。他说啊，你去那儿注册这样账号，我已经有账号。他说你去你生成一个东西，那个哪个点哪个标点，然后你给我一个东西。然后我说我要不要给你密码，他说别别在这输，他说你想的只要怎么怎么样，然后我告诉你放到输到什么地方。他什么都告诉你。然后再往以后就是，我说哎，你是不是版本管理一下，你自己找一个合适的方式，该不然是不然是，该咋咋。他自己哦行，甭管了，他自己咔咔咔先版本控制。所以，所以非常，真的我跟你说AI的潜能是我我只能说咱们现在六个人，咱们还是在低估这个AI潜能。你还是那句话，你不知道他能干什么，是因为是你不知道，是刚才是有人说的吧，是谁，就是咱们不知道，你其实还能那么压榨他。你去扣扣扣，他是能白日百替你工作。我昨天我就是说，我说我现在忙别的事了，你别烦我，你自己把它搞定。然后我回去之后他搞定了，就是这样。他中间没有问我任何事情。</p>

            <h2>议题三：Prompt Engineering 与 Sudo Code</h2>
            <p><b>Dusing:</b> 其实我们可以讨论下一个主题，下一个主题是什么？我看一下喔，Thomas想说，他虽然他不在，但是他有列一个主题是要跟大家讨论Prompt Engineering，然后这边他有特别指出sudo code的部分。Sudo code（伪代码）就是说，它的意思是说你在做Promt的时候，你在写Promt的时候，有一些地方你可以尝试用我们Coding会用的格式，譬如说JSON的格式，譬如说SQL的格式这样子，这样子LLM会比较容易理解。这个我没有测试，它真的是这样子。就是你可以很简单很简单，就譬如说跟他讲说你现在要做一个if，可能给他一个if else之类的，这样子也可以，他就知道要做什么了。所以他的意思是说，那他这样子做什么目的？我去查了一下发现，其实我们做Vibe Coding做到最后，其实有一个部分是这样，就是AI它还是有随机性，然后我们还是会需要去想要去控制它出来产出的品质，或是说至少它的产出的品质可以稳定，它产出的结果可以稳定一点。所以就有一些人他就主张说，其实我们可以使用sudo code。大家有用过这个技巧吗？</p>
            <p><b>Ray:</b> 我用过。我先说，sudo code它有两个层面啊。第一个，to be honest，我觉得在绝大多数情况下不需要sudo code的。这是在prompt engineering早期的时候，可能大家你需要sudo code的，让他去能够按照follow一个structure或者怎么样。现在真的是不需要。现在其实我刚一直想问大家问题，你在vibe coding的时候，你是用打字的吗还是用嘴说的？</p>
            <p><b>Dusing:</b> 打字。</p>
            <p><b>Ray:</b> 哎，你一定要用嘴说，你一定要用嘴说。真的，你嘴说呜呀呜呀呜啦呜啦跟他，我不好意思我就要吵，我那坐着我的那个那丁嘴豆浆。然后那个就是，你一定要嘴说，你跟呜啦呜啦说的东西好像似乎没有逻辑，他完全能get。就好像我在咱们那个节目我发了一段我跟他对话，你去看你完全不知道我在说什么，我都不知道我在说什么，但是AI知道我在说什么。OK，那那回到sudo code，就是说，语言会提高你的输入效率，你输入会快很多。但有时候需要去写，有时候需要你仔细思考的需要去写，但有些东西你自己没有思考清楚的，你应该去说。这是我现在的一个基本的原则。</p>
            <p><b>Ray:</b> 那回到sudo code，sudo code我认为早期的工程师的时候你可能需要sudo code，但是到了现在这个节点一般不需要。但是在一种情况下，就结构化的输出的时候，你可能需要sudo code。我最近就prompt的那个Gemini 1.5 Pro，他那个token很长，我让他输出一些固定格式的时候，我要给他一个，让他就是，有让他写成一个JSON的格式。但是我不会写，我呜哩呜哩跟他对话了半天之后，我说行，你根据咱俩刚才对话这些东西，你给我想一个prompt，然后你你给我放到一个JSON的一个structure里。就说，即使sudo code也不要自己去写。这是我想说的，就是让AI接管一切，让AI接管一切。我认为这是个非常重要的mindset。然后你只需要告诉他做什么，而不是你要去做什么。就是你想写sudo code，你也可以。比如说像Gemini 1.5 Pro我觉得非常好，你能跟他对话很长时间，对他很长时间之后，他理解你的所有的intention，你的逻辑，你让他给你写prompt engineer，然后给你写sudo code，让你干什么干什么，他全都知道。这个对话非常的珍贵。然后当你想去structural的这种output的时候，你比如说我做了一个咱们社区的一个东西，一个自动，就是咱们今天的对话最后会变成clips，就是里面会有精彩的瞬间，比如刚才谁的精彩发言之类的，我就让Gemini自己给我弄，给我切片，然后最后输出格式化的就是一个cutlist，一个CSV文件。这个CSV文件那样自动就会把这个视频咔给剪出来了。其实我已经在以前在这个咱社区里发过直播，我想把这个东西更加的自动化，我现在正在做一个App就要实现这个事情。那这个structural的output这时候就很重要。因为大语言模型它输出很多的这个token的时候，我现在用n8n（一个开源的工作流自动化工具），n8n里面它有专门有一个structural的，叫做那个是一个什么什么passer，就是把大元模型的这个东西变成一个结构化的。其实就是因为像我们最早GPT那个tool calling啊什么之类的，你给它一个格式，JSON格式，它就输出一个什么什么什么那样的东西。其实对处于这种token很长这种文字来说，这是我个人经验是比较有用，因为你想结构化的从里面一下出来很多东西，然后这一块我要这个字段，那一块要那个字段，然后在不同的流程中，公众流程中给他不同的处理的分支。这是我的一个经验，但我不认为sudo code是你自己需要掌握的，但你需要知道有sudo code和structural output这个概念，然后交给AI去做就好了。</p>
            
            <h2>议题四：Apple论文“Illusion of Thinking”引发的思考</h2>
            <h3>问题复杂度与AI的推理极限</h3>
            <p><b>Dusing:</b> 我们终于有半个小时了，然后我想跟大家讲一个很我觉得很珍贵的主题，因为这个非常非常的有意思，因为我们几乎所有人现在都在用推理式的模型，就是他会思考的模型。那这一篇这个主题是这样，这个研究Apple最近也有他自己的大会，他自己的大会他提出来的一篇论文，虽然Apple的AI还是没有到那么厉害，但是他写这个论文很有意思，他这个论文叫做“Illusion of Thinking”（思考的幻觉）。就是说他在去调查了市面上的推理式模型，他去做了一些测试跟研究。他测什么呢？他测说这些推理式模型他可以解决问题的复杂度，问题可以解决到多复杂。那它的复杂度它用测试的是我们coding里面用的一些演算法、资料结构的问题。在我给你们这个链接在chat里面，这个链接它的那个论文里面有列出来，基本上就是我们很经典的一些问题。然后它发现说，当问题越来越复杂，复杂到一临界点，所有的model都表现得一样烂，不管你是哪一家的，不管你用了多少的input在你的LLM里面。所以它的意思是这样子，就是说LLM它的思考流程它是会有错误的，它是想讲这件事情。然后它要怎么避免这个错误它没有讲。但是我觉得它里面做的测试跟我实际上的经验是很像的。就是我们的场景是这样子，我们可能一开始跟她讲说，请你做一个app可以让我留意我的食材，然后生产出随机生产菜单，就我们很简单的讲这样子，它可能会出现一个雏形，但是那个雏形有可能有可能是错误百出，因为那个问题对他来说可能会太复杂。我自己也遇到一样的状况，然后我去看了这篇论文，大概有发现说，其实理解他的方式，解决的方式其实也是非常单纯，其实就是真的就是把大问题把它拆成小问题。那大家有没有类似的经验？</p>
            <p><b>Ray:</b> Vibe coding很重要一点就是focus on小问题，千万不要被他这个妩媚的AI骗了，他上来给了你一个非常好完整的开发的路线，然后呢里面写的可清楚了，然后下一步我要给你改进什么什么东西，给你promise特别特别好，但是你一次只做一个事，一次只做一个事。这就是我的一个建议，就是你把他break down，就他给了你一个更高层次的一个东西，一个todo list，然后你自己可以去manage，你可以在自己的，就像我在MindNode或怎么样，我有manage，甚至我会让另外一个AI去帮我manage。但是你每次真的你只focus这一个东西，把这一个东西focus好，这个问题解决了，再去move on下一个。千万不要有那个被他这个有这个temptation，就是哇一下搞很多。我现在最多就是一次让他可能搞两，就是我觉得这两个事能一起做我就跟他说，但一般来说我一次只让他搞一个事。这点很重要。</p>
            <p><b>Amy:</b> 我只是想复合一下，因为我在做那个App的时候，我发现但凡我提两个需求，他出bug的几率就会比一个要高。然后对，因为是那种很小很小的一个改动，然后他可能，比如说两个小改动吧，我让他同时，因为有的时候我觉得他那个，就是比如说我提一个需求，他再反过来需要一点时间嘛，然后我就想偷懒，我就说能不能一次提两个，然后一次提两个他就会给我制造更多的麻烦，我需要花费更多的时间。</p>
            <p><b>Vincent:</b> 像Amy你这种情况，你可以比如说因为你是需求，在大家开始动手之前，你可以请他先做需求分解，分解完之后再根据去分解出来的需求，再请他提出技术方案，然后列出来给你听。等你都觉得没问题了，你再请他去针对这个分解出来的需求去一个一个解决。就是你以为的需求可能是这么大，但是实际上你念给他听之后，他还是可以再分解的。那就是你可以请他再继续分解到像刚才Ray讲的非常非常具体的一个小需求之后，你再请他去做那个小需求。但在做之前，请他再根据这个小需求提出技术方案。那做这一点不一定是是为了要看看技术方案，而是你要确保他想过这件事情。那他，你有没有问过这个问题，他最后改出来的code会有差异的。</p>

            <h3>AI的知识边界与真实世界问题</h3>
            <p><b>Jay:</b> 我之前问过一个问题，这个问题其实它的结果挺出乎我意料的。前段时间我问AI一个问题，因为我要去Yukon徒步嘛，然后我就问他八月份，然后我要准备各种各样的装备什么的，衣服啊什么的。然后我就问他说，给我一个平均八月份Yukon的天气，就是给我一个Yukon八月份天气的预报，就这么一句话，结果AI想差不多五分钟，然后给了一个很糟糕的答案。</p>
            <p><b>Ray:</b> 我觉得啊，我觉得这不是一个难的问题，这个是一个很简单的问题，他缺的就是你这个AI他没有那个数据，他没有那个数据而已。这是我的，他找不到，他找不到，他其实不是很好的能找到这个数据，而Yukon这个地儿就咱家，谁去啊？</p>
            <p><b>Dusing:</b> 对，好像上次有聊到就是医疗的东西嘛，就是AI的，我们现有的AI在医疗的support是是没有那么好的，尤其是很多医疗论文，他医疗论文的资料是没有的，所以你问他一些医疗的问题或健康方面的问题，有时候他的答案是大概五年前、十年前的答案，可是有很多都是有新的研究出来。</p>
            <p><b>Ray:</b> 我再举一个例子，因为我要转录很多文本，把音频变成文字，我要做很多这种事情。我用的所有的AI到现在，我要求他用ElevenLabs的API，他们所有的AI到最后都会给我pivot，他说那玩意儿不好使，咱们用Whisper吧。因为他不知道ElevenLabs的新的API有多么的强大，那是应该刚出了几个月的一个语音转文字。就simply就是他训练的，他第一他不知道这信息，然后而且即使他去查他也查不好。我现在都怎么这样，我就把那个API的Documents那个网页喂给他，然后我甚至把里面具体的小的章节我也喂给他。我告诉你，记住，你写好自己文档以后就参考他，我以后never ever给我提Whisper。其实我不觉得那是个大问题，他就是我们必须要明白他的limitation，他其实搜索他不一定能搜索很好，有时候你其实人为给他一些东西可能会更好一些。你比如说如果你去找到一个database，Yukon的database很简单，你去看分析它历史的温度、湿度、干嘛，你告诉我应该穿什么，它很容易就做到，对不对？但是你没有这个，你让他去找，突然这个问题scope其实就有点大，它能够想明白这个逻辑，但它simply找不到，因为我们也找不到Yukon的这个东西，真的找不到。</p>
            <p><b>Jay:</b> 这个问题是可以关乎到我的生命危险的。就是因为我要在那边生存，它是可以关乎到我的生命危险的。所以它如果给我一些，基于数据之外，它如果没有一个具体数据，基于数据之外，它自己做一个推理，我是不太敢去相信它的。我是必须得类似于，就是我宁可去问一个向导，真的在那边徒步过的向导，我会更愿意相信这个source，而不是AI的source。因为如果AI给我一个，它就不用负责任。</p>
            <p><b>Ray:</b> 这就是为什么real world AI非常重要。就是其实你好像感觉现在AI无所不能，但他实际上他的knowledge全是互联网上这些text。那你real world，就好像你想来Banff徒步，你不用，你直接给我打一电话我就告你了。这种local knowledge，就我家小区哪一块你拐弯的时候那有个坑你得小心一点，这种local knowledge是AI所没有的。很多人说而现在AI已经穷尽了网上所有的东西，那只是穷尽网上，但我们的现实世界里头90%是发生在real world，不是在网上。这很不幸，就是程序员把自己的90%的东西都放到网上了，让AI先学会了。所以这是为什么现在AI能够先把这个90%的程序员的工作给干掉。</p>
            
            <h2>总结与展望：我们与AI的协作关系</h2>
            <p><b>Ray:</b> 我现在有个信念，几乎我们现在大家处理的大多数问题没有AI不能解决的，而是你不知道怎么让它去解决。所以Vibe Coding最重要一点是，你里面会遇到很多的frustration，一定记住，这些所有的frustration都是你的问题，不是AI的问题。你记住这句话，都是你的问题，不是AI的问题。</p>
            <p><b>Jay:</b> 在我们做Vibe Coding的时候，其实有两条极限。一条是你推进你自己的知识范围的极限，当你开始问你超出自己知识范围的问题的时候，你会有一个很大的不安全感和不确定性，其实很多时候你没办法确定这个结果是不是对的。另一条线呢，就是说AI的能力范围。这个问题其实出现在一年前，一年前AI是有能力范围限制的，但现在这个能力范围我们好像还没探索到。</p>
            <p><b>Ray:</b> 其实还是能探索到。我们碰到的限制都是自己的限制，我们碰到的边界都是自己的边界。这是我Vibe Coding这么长时间，用AI这么长时间，原来我们touch到的全都是自己的限制，自己的边界。对，就找自己的问题就是最对的。</p>
            <p><b>Jay:</b> 不能这么绝对的说，绝对有一部分，我不相信AI现在他能够百分百做完。</p>
            <p><b>Ray:</b> 那我的判断是说，比如说这就像你刚才说的那个data问题，你说这是AI解决不了，但实际上是我们的问题。我要能给它提供这AI提供data，它就能解决。就是说，如果你的目的是为了解决问题，是通AI跟你协助解决问题，那你没有能有这么好的工具，你没有去使用它去来辅助你。就好像电是个很好的东西，但是电它不能把你从A传送到B。但你说这是电的限制，我不用电了。那不是这样，而是你怎么想这个工具放到我的身上，能跟我一起来实现目的。很多人的问题就在他只是看AI的这块做不了，但实际上是更多是自己不知道怎么去用这个工具能够去帮助他去实现。</p>
            <p><b>Jay:</b> AI有一个限制是在于它对于没有数据的这么一个问题，或者说之前没有人post过的这个问题，也没有被训练过的这个问题，它做出的这个回答完全靠它自己的想象，或者完全靠它自己的对语言的这种理解，这是一个没有逻辑的行为。所以说如果你没有这个数据支持，比如说我这个Yukon问题，从来没有人提过Yukon，从来没有人post过这个数据，那我如果问它这个问题，这就是AI的限制，AI答不了这个问题。</p>
            <p><b>Ray:</b> 这不是我们的限制，这是我们的限制。你没有实现你的目的，这就是你的限制了。这是我的点。你也是达到你的限制，因为你也没有解决这个问题。这就是为什么我们作为人现在还有意义的地方，就是因为我能够去跟AI配合，我去实现这个东西。我不是为了测试AI怎么样，I don't really care about that。对我只care我能不能用好这个东西去帮我实现。就是我说遇到我们的限制的问题，就是我们自己的边界问题。就是因为，就好像比如现在大模型不行，那现在是我也是我们的问题，为什么？因为我们没有办法把这个大模型变得让它更厉害，这就是我们要解决的问题嘛。所以你遇到所有的问题，永远是人的问题，不是AI的问题，是我们自己的限制。</p>
            <p><b>Dusing:</b> 我觉得就是有两种限制，就是看是到底是工具本身它的极限，还是说它就是没有这个知识。我觉得这两个东西是要去分开的。就是它一旦被辨识的话，就能够被处理。因为如果是工具的限制的话，你就想办法给它那个工具。如果是知识的限制的话，如果这个世界上都没有人有这个知识，那我觉得我也没办法期待它会有。</p>
            <p><b>Jay:</b> 读心你说的有个很好，就是工具本身的限制，我可以理解为它是一个推理能力的限制，它推理能力可能有一个极限，有时候你可能给它一定的支持，它如果推理能力不够，它就是推理不出来，它就是没法给你一个对的答案。</p>
            <p><b>Ray:</b> 所以我觉得你是要让它细化，它可能就是大的问题，它要经过多少几十步几百步的推理，那你帮它分成一步一步的小部分，它一次就做比方说只做两个Chain of Thought，对吧，就是只做两个判断就OK了。然后你把这几千个这个小的模块放在一块，它还是可以完成一个复杂度很高的一个推理任务。所以你看还是人的问题。</p>
            <p><b>Dusing:</b> 我觉得这个句话非常适合来当我们的总结，因为我们时间已经到了。然后我想要再帮Ray宣传一下，就是明天的时间大家自己看，就是还有一场Vibe Coding的讨论，那请大家有空记得参加哦。好，谢谢大家，我们AI Vibe Coding的Program真的顺利毕业了，感谢大家。那我们接下来就是在AI Vibe Coding的space见了。好，感谢大家。</p>
            <p><b>众人:</b> 谢谢大家，谢谢大家的评论，我也看到很有意思的评论，谢谢。感谢大家参与，拜拜。</p>

            <div class="action-buttons">
                <button id="copy-md-button">一键复制为Markdown</button>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // 仅当内容超过3000字时，AI才应生成包含目录的HTML结构，此JS仅用于填充
        if (document.getElementById('toc-container') && document.getElementById('toc-container').innerHTML.trim() === "") {
            generateTableOfContents();
        }
        initializeCopyToMarkdown();
    });

    function generateTableOfContents() {
        const contentBody = document.getElementById('content-body');
        const tocContainer = document.getElementById('toc-container');
        if (!contentBody || !tocContainer) return;

        const headings = contentBody.querySelectorAll('h2, h3');
        if (headings.length > 0) {
            tocContainer.innerHTML = '<h3>目录</h3>';
            const tocList = document.createElement('ul');
            headings.forEach((heading, index) => {
                const id = `heading-${index}`;
                heading.setAttribute('id', id);
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.setAttribute('href', `#${id}`);
                link.textContent = heading.textContent;

                if (heading.tagName === 'H3') {
                    link.style.paddingLeft = '15px';
                }

                listItem.appendChild(link);
                tocList.appendChild(listItem);
            });
            tocContainer.appendChild(tocList);
        } else {
            tocContainer.style.display = 'none';
        }
    }

    function initializeCopyToMarkdown() {
        const copyButton = document.getElementById('copy-md-button'); // 假设此按钮在main-content内
        if (!copyButton) return;

        copyButton.addEventListener('click', () => {
            const contentBody = document.getElementById('content-body').cloneNode(true);
            // 移除按钮容器防止被复制
            const buttonContainer = contentBody.querySelector('.action-buttons');
            if (buttonContainer) {
                buttonContainer.remove();
            }

            if (contentBody && typeof TurndownService === 'function') {
                var turndownService = new TurndownService({ headingStyle: 'atx' });
                
                turndownService.addRule('pWithBold', {
                    filter: function (node, options) {
                        return (
                            node.nodeName === 'P' &&
                            node.firstChild &&
                            node.firstChild.nodeName === 'B'
                        );
                    },
                    replacement: function (content, node, options) {
                        // 将 <p><b>Speaker:</b> Text</p> 转换为 **Speaker:** Text
                        const speaker = node.querySelector('b').textContent;
                        const text = node.textContent.replace(speaker, '').trim();
                        return `**${speaker}** ${text}\n\n`;
                    }
                });

                var markdown = turndownService.turndown(contentBody);
                
                navigator.clipboard.writeText(markdown).then(() => {
                    copyButton.textContent = '复制成功!';
                    setTimeout(() => { copyButton.textContent = '一键复制为Markdown'; }, 2000);
                }).catch(err => {
                    console.error('复制失败: ', err);
                    copyButton.textContent = '复制失败';
                });
            }
        });
    }
    </script>
</body>
</html>