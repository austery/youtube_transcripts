---
title: "AI and the Future of Software Development"
layout: "post.njk"  
date: "2025-05-28"
tags:
  - "视频笔记"
data:
  author: "Lei"
  podcast_program: ""
  speaker: ""
  guest: "" 
  source: ""
---

<div class="container">

# AI and the Future of Software Development

**Speakers:** The discussion features several individuals, including
those explicitly named as Guido and Yoko, discussing the role of AI in
software development. Other participants contribute to the conversation.

**讲述者：**
讨论由几位人士参与，其中包括明确提到的Guido和Yoko，他们共同探讨人工智能在软件开发中的作用。其他参与者也为对话做出了贡献。

## The Evolving Role of AI in Programming / 人工智能在编程中角色的演变

<div class="section-en">

One speaker initiated the discussion by questioning whether AI,
currently not a higher-level language abstraction, could evolve into one
over time. This speaker expressed a belief that it could. Reflecting on
classic compiler design and programming languages, the speaker suggested
that if Large Language Models (LLMs) were available as a tool, the
approach to building a compiler would likely be very different. Although
this transformation has not yet fully materialized, the potential for
defining things in human language efficiently and precisely enough to
serve as direct input for a compiler could significantly alter many
aspects of software development.



<div class="section-zh">

一位发言者首先提出问题，探讨当前并非高级语言抽象的人工智能，未来是否可能演变成这样。该发言者表示相信这种可能性。回顾经典的编译器设计和编程语言，他认为如果大型语言模型（LLMs）能作为工具使用，构建编译器的方法可能会大相径庭。尽管这种转变尚未完全实现，但以高效、严谨的人类语言定义事物，并将其直接用作编译器输入，这种潜力可能会极大地改变软件开发的诸多方面。



## The AI Coding Market / 人工智能编码市场

<div class="section-en">

It was posited that AI coding is currently the second biggest AI market,
following consumer pure chatbot applications. However, another speaker
argued that if one considers homogeneous markets, coding might actually
be the largest. When asked if coding is bigger than AI companions, the
consensus was affirmative, at least at this point. It was acknowledged
that classification can be tricky, as a significant portion of ChatGPT
usage, for instance, could be considered companionship. Ultimately, the
motivations to build something versus finding companionship are both
strong human drivers, potentially making them comparable in
significance.



<div class="section-zh">

有观点认为，人工智能编码是当前第二大人工智能市场，仅次于纯消费级聊天机器人应用。然而，另一位发言者提出，如果考虑同质化市场，编码实际上可能是最大的市场。当被问及编码市场是否大于人工智能伴侣市场时，与会者一致表示肯定，至少目前如此。发言者也承认分类可能比较复杂，例如，ChatGPT
的很大一部分用途可被视为伴侣性质。最终，创造事物的动机与寻求陪伴的动机都是强大的人类驱动力，可能使其在重要性上具有可比性。



## Existing Behaviors and Early Adoption / 现有行为与早期采用

<div class="section-en">

A unique aspect of AI coding, sometimes underappreciated, is its
foundation in existing behaviors. Developers were already accustomed to
seeking help online, primarily on Stack Overflow. AI coding tools
represent a significantly improved form of this behavior. The common
joke that Stack Overflow has been writing most of the code for years
might see a shift, with AI models taking over that role. Furthermore,
foundational work by tools like GitHub Copilot began transitioning users
from Stack Overflow to AI models. Companies like Cursor are now
considered to have further refined this experience. This leverages an
existing user behavior and market, allowing for the introduction of a
superior product.

Another factor contributing to the success of the AI coding market is
that developers, when given access to new AI technology, naturally apply
it to solve their own problems first. They understand these problems
best and build infrastructure for their own use. Developers are
typically early adopters, eager to tinker with new tools, and appreciate
anything that boosts productivity. The verifiability of coding
problems—where inputs and outputs are clear, unlike subjective user
preferences—also plays a role. Many diverse problems can be reframed as
coding tasks. It was even argued that some art generation could be
considered a coding problem, citing historical machine learning use in
Adobe Photoshop for mapping brush trajectories or vector generation,
which are essentially coding tasks. The appeal of code lies in its
ability to model real-world problems into machine-consumable formats.



<div class="section-zh">

人工智能编码一个独特且有时被低估的方面是，它建立在已有的行为基础之上。开发者早已习惯在遇到问题时上网寻求帮助，主要是在
Stack Overflow
上。人工智能编码工具是这种行为的一种显著改进形式。过去常说 Stack
Overflow
编写了大部分代码的笑话，现在可能随着人工智能模型接管这一角色而发生转变。此外，像
GitHub Copilot 这样的工具所做的基础性工作，已经开始引导用户从 Stack
Overflow 转向人工智能模型。像 Cursor
这样的公司现在被认为进一步完善了这种体验。这利用了现有的用户行为和市场，从而能够将更优质的产品引入其中。

人工智能编码市场成功的另一个因素是，当开发者获得新的人工智能技术时，他们自然会首先将其应用于解决自身问题。他们最了解这些问题，并为自己构建基础设施。开发者通常是新技术的早期采用者，热衷于尝试新工具，并乐于接受任何能提高生产力的东西。编码问题的可验证性——输入输出清晰，不像主观的用户偏好——也起到了作用。许多不同类型的问题都可以被重新构建为编码任务。甚至有观点认为，某些艺术创作也可以被视为编码问题，并列举了历史上
Adobe Photoshop
中使用机器学习来映射笔刷轨迹或生成矢量图的例子，这些本质上都是编码任务。代码的魅力在于它能够将现实世界的问题建模成机器可处理的格式。



## Market Size and Value Unlocked / 市场规模与释放的价值

<div class="section-en">

The market is massive. With approximately 30 million developers
worldwide, each creating an average value of \$100,000 per year, the
total value is \$3 trillion. Data from large financial institutions
estimate that even a standard Co-pilot deployment increases developer
productivity by about 15%. One speaker expressed a gut feeling that this
productivity gain could be substantially higher, potentially doubling
developer productivity. This would unlock an additional \$3 trillion in
value globally, comparable to the value of Apple. This vast potential
for value creation dwarfs previous concerns about overinvestment in AI,
such as a \$200 billion annual investment figure discussed previously.
The ease of capturing this market, due to developer understanding and
its sheer size, positions AI in coding as potentially the first truly
large market driver for AI.

Software and software developers create immense value in every
organization worldwide. AI offers a shortcut to enhancing this core
capability, making its impact significant.



<div class="section-zh">

这个市场规模巨大。全球约有 3000 万名开发者，每人每年平均创造 10
万美元的价值，总价值高达 3
万亿美元。来自大型金融机构的数据估计，即使是标准的 Co-pilot
部署也能将开发者生产力提高约
15%。一位发言者凭直觉认为，这种生产力提升的幅度可能会大得多，甚至可能使开发者生产力翻倍。这将释放全球额外的
3
万亿美元价值，与苹果公司的市值相当。这种巨大的价值创造潜力，使得先前关于人工智能投资过度的担忧（例如之前讨论的每年
2000
亿美元的投资额）相形见绌。由于开发者对此易于理解且市场规模庞大，人工智能在编码领域的应用有望成为人工智能首个真正的大型市场驱动力。

软件和软件开发者在全球每个组织中都创造着巨大的价值。人工智能为增强这一核心能力提供了一条捷径，使其影响深远。



## The Future of the Software Developer Role / 软件开发者角色的未来

<div class="section-en">

A bootstrapping effect was noted: better AI coding models lead to the
creation of better software and new AI applications, creating a virtuous
cycle. This raised the question of how the job of a software developer
will look after the AI revolution. One speaker, Guido, shared that his
current coding process involves writing specifications and discussing
implementation details with an AI model. For simple features, he can ask
the AI to implement them and then review the code. The discussion
pondered whether developers will all become product managers writing
specifications, with AI handling the coding and humans stepping in for
debugging, or if they will become QA engineers testing against
specifications. The irony of developers potentially becoming QA
engineers, a role many sought to avoid, was acknowledged.



<div class="section-zh">

与会者注意到了一个“自举效应”：更好的人工智能编码模型有助于创建更好的软件和新的人工智能应用，从而形成一个良性循环。这引出了一个问题：在人工智能革命之后，软件开发者的工作将会是什么样子？一位发言者
Guido
分享说，他目前的编码过程包括编写规范，并与人工智能模型讨论实现细节。对于简单的功能，他可以让AI来实现，然后自己审查代码。讨论中探讨了开发者是否都会转变为编写规范的产品经理，由人工智能负责编码，人类仅在调试时介入；或者开发者是否会变成对照规范进行测试的QA工程师。开发者可能最终变成他们许多人试图避免的QA工程师角色，这一点颇具讽刺意味。



## Current AI Coding Workflows / 当前的人工智能编码工作流

<div class="section-en">

Guido elaborated on how his use of AI models for coding has evolved
significantly even in the last six months. Initially, it involved
prompting a model like ChatGPT, copying the generated code into an
editor, and testing it—essentially a Stack Overflow replacement. This
was state-of-the-art about nine months ago. The next step involved
IDE-integrated tools like GitHub Copilot and Cursor, enabling
autocomplete, which was a major step forward from monolithic questions
to an in-flow experience. This further split into line-level
autocomplete, the ability to ask questions about code blocks, and
separate chat interfaces for longer discussions. IDEs then began
incorporating command-line tool usage, allowing AI to set up projects
(e.g., a new Python project with UV). Currently, when Guido wants to
write new software (for experimentation, not production), he starts by
writing a high-level, somewhat abstract spec. He then asks a model (like
GPT-3.5 or Gemini) for feedback, to ask clarifying questions, and to
write a more detailed spec. This often involves a back-and-forth
discussion where the model acts as a sparring partner, helping to
clarify his thinking. This includes providing context like API keys,
discussing state management (database vs. file), and adhering to his
standard Python coding guidelines (commenting style, object-oriented vs.
procedural, class structure, typed vs. untyped Python). The process is
about context, development methodology, and collaborative
problem-solving with the model.

Yoko described her changing workflow over the past six months. She now
provides more "world knowledge" to the coding agent, rather than relying
solely on the foundational model's knowledge, which often has a dated
knowledge cut-off (e.g., thinking "today" is 2023). Her current workflow
might involve creating a ticket in Linear with an idea, which is then
pulled into Cursor for an agent to take the first stab at
implementation. Another change is more user-prompted active queries.
Instead of manually copy-pasting documentation, she can now ask the
Cursor agent to use a tool like Firecrawl to search for the latest
documentation (e.g., Clerk documentation), which it fetches and
processes. This demonstrates increased integration with real-world,
up-to-date information.

A third speaker described a more spontaneous approach: using free time
on a Saturday night to dive into a "weird idea for an app," asking
Cursor to handle everything. This works particularly well for
high-complexity, high-annoyance tasks like front-end development,
especially with CSS classes for margins and padding, which are
notoriously difficult to remember. The challenge of centering a div was
humorously noted as a benchmark for AI capability. AI models excel at
these kinds of tasks. However, issues arise with more niche libraries
and function calls. The Firecrawl idea was praised for its ability to
fetch documentation, a common manual workaround.

Yoko also mentioned sometimes copy-pasting documentation URLs (e.g.,
Minify docs with \`lm.ext\` for developer tools) into Cursor, asking it
to implement based on that, which also works.



<div class="section-zh">

Guido
详细阐述了他使用人工智能模型进行编码的方式在过去六个月里发生的显著变化。最初，这包括给像
ChatGPT 这样的模型提示，将生成的代码复制到编辑器中并进行测试——本质上是
Stack Overflow
的替代品。这在约九个月前还是最先进的技术。下一步则涉及到集成到 IDE
中的工具，如 GitHub Copilot 和
Cursor，实现了自动补全功能，这是从单一问题到融入工作流体验的一大进步。这进一步细分为行级自动补全、对代码块提问的能力，以及用于更长讨论的独立聊天界面。随后，IDE
开始集成命令行工具的使用，允许人工智能设置项目（例如，使用 UV 创建新的
Python 项目）。目前，当 Guido
想要编写新软件（用于实验而非生产）时，他会从编写一个高级别的、有些抽象的规范开始。然后，他会请求模型（如
GPT-3.5 或
Gemini）提供反馈、提出澄清问题，并编写更详细的规范。这通常涉及来回讨论，模型充当陪练伙伴，帮助他理清思路。这包括提供
API 密钥等上下文信息，讨论状态管理（数据库与文件），并遵循他的标准
Python 编码指南（注释风格、面向对象与过程式、类结构、类型化与非类型化
Python）。这个过程关乎上下文、开发方法论以及与模型的协作解决问题。

Yoko
描述了她过去六个月中工作流程的变化。她现在为编码代理提供更多的“世界知识”，而不是仅仅依赖基础模型的知识，因为基础模型的知识截止日期通常比较旧（例如，认为“今天”是2023年）。她目前的工作流程可能包括在
Linear 中创建一个包含想法的工单，然后将其导入
Cursor，让代理初步尝试实现。另一个变化是更多由用户发起的即时查询。她现在不必手动复制粘贴文档，而是可以要求
Cursor 代理使用像 Firecrawl 这样的工具来搜索最新的文档（例如 Clerk
文档），代理会获取并处理这些文档。这表明与现实世界最新信息的集成度有所提高。

第三位发言者描述了一种更为即兴的方法：利用周六晚上的空闲时间，投入到一个“奇怪的应用程序想法”中，让
Cursor
处理所有事情。这种方法对于高复杂度、高烦人系数的任务（如前端开发）尤其有效，特别是处理用于边距和内边距的
CSS
类，这些类是众所周知的难以记住。“div居中”的挑战被幽默地指出是衡量人工智能能力的一个基准。人工智能模型在处理这类任务方面表现出色。然而，在涉及更小众的库和函数调用时，问题就会出现。Firecrawl
能够获取文档的想法受到了称赞，因为这通常需要手动解决。

Yoko 还提到，有时她会复制粘贴文档 URL（例如，带有 \`lm.ext\`
供开发者工具使用的 Minify 文档）到 Cursor
中，要求它基于此进行实现，这种方法也行之有效。



## Challenges and Agent Behavior / 挑战与代理行为

<div class="section-en">

When asked about things going wrong with AI-assisted coding, Yoko shared
an instance where agent behavior was key. Using a tool that generates
pretty pages and returns a React component or HTML for a coding agent to
reference, she asked the Cursor agent to implement based on the tool's
output. The Cursor agent, however, looked at the code, commented that it
looked great, and then offered to provide a \*new\* version, rather than
adopting the provided one. This highlighted an interesting aspect of
agent-to-agent communication, where one agent might "disagree" with
another's direction.

Yoko, who has worked on MCP (Multi-Context Prompts), explained that MCP
is essentially a way to provide the most relevant context to LLMs. This
allows long-tail MCP servers to be leveraged by various clients,
empowering experiences like fetching specific documentation. Tool
calling is a technical detail of how context is fetched, but the crux of
MCP is the context itself: providing the most relevant information to
the model for better assistance.



<div class="section-zh">

当被问及人工智能辅助编码中出现的问题时，Yoko
分享了一个代理行为是关键的例子。她使用一个能够生成精美页面并返回 React
组件或 HTML 供编码代理参考的工具，然后她要求 Cursor
代理根据该工具的输出进行实现。然而，Cursor
代理查看了代码，评论说它看起来很棒，然后提出要提供一个\*新\*版本，而不是采用提供的版本。这突显了代理之间通信的一个有趣方面，即一个代理可能会“不同意”另一个代理的方向。

曾参与 MCP（多上下文提示）工作的 Yoko 解释说，MCP
本质上是一种向大型语言模型提供最相关上下文的方法。这使得各种客户端能够利用长尾
MCP
服务器，从而实现诸如获取特定文档之类的体验。工具调用是获取上下文的技术细节，但
MCP 的核心在于上下文本身：向模型提供最相关的信息以获得更好的辅助。



## AI for Different Developer Levels and Problem Complexity / 面向不同级别开发者和问题复杂度的人工智能

<div class="section-en">

The discussion turned to whether AI coding tools are more productive for
senior developers, potentially engaging "neckbeards" (highly
experienced, often skeptical engineers) who might have been wary of
earlier AI tools that produced good demos but lacked depth. Yoko
suggested it depends on what senior engineers are optimizing for. For
senior application engineers skilled at fleshing out ideas, AI can help
distribute skill sets. However, for those optimizing for highly
specialized areas like distributed systems, current AI coding agents are
not quite there, partly due to limitations in fetching all necessary
system states and the need for human intervention. However, with larger
context windows and better tool-calling capabilities, this could
improve. Current IDEs often have limits on the number of tools an agent
can handle (e.g., 40-50), naturally restricting context and
capabilities.

It was observed that the more esoteric or novel the problem, the more
context needs to be provided. For standard problems (e.g., a simple
online store, common in undergraduate classes), models have seen
countless examples and can regurgitate code well. For problems with
little training data, users must specify exactly what they want, provide
all context and API specifications. Models can also confidently
hallucinate non-existent functions. If pointed out, they might apologize
and hallucinate another non-existent function. Models are currently poor
at admitting when they do not know something. When asked if
Reinforcement Learning (RL) could change this, the response was
skeptical for truly novel problems with zero training data. AI models
are not yet truly creative in these scenarios; for instance, writing a
driver for a brand-new chip architecture would still be a largely manual
task. Fortunately, this represents a tiny fraction (e.g., 0.01%) of all
software development. For the vast majority of tasks, like implementing
another ERP system, where ample training data exists, these tools can be
very powerful.



<div class="section-zh">

讨论转向人工智能编码工具是否对高级开发者更具生产力，以及是否能吸引那些对早期人工智能工具（这些工具能生成不错的演示但缺乏深度）持怀疑态度的“老法师”（经验丰富但通常持怀疑态度的工程师）。Yoko
认为这取决于高级工程师优化的目标。对于擅长将想法具体化的高级应用工程师，人工智能可以帮助分配技能组合。然而，对于那些优化高度专业化领域（如分布式系统）的工程师，当前的人工智能编码代理尚未达到要求，部分原因是其在获取所有必要系统状态方面存在局限，且需要人工干预。不过，随着上下文窗口的扩大和工具调用能力的增强，这种情况可能会改善。目前的
IDE 通常对代理可以处理的工具数量有限制（例如 40-50
个），这自然限制了上下文和能力。

与会者观察到，问题越深奥或越新颖，需要提供的上下文就越多。对于标准问题（例如，简单的在线商店，常见于本科课程），模型已经见过无数示例，能够很好地“复述”代码。对于训练数据很少的问题，用户必须精确指定他们想要什么，提供所有上下文和
API
规范。模型也可能自信地“幻觉”出不存在的函数。如果被指出，它们可能会道歉并幻觉出另一个不存在的函数。目前模型不擅长承认自己不知道某事。当被问及强化学习（RL）是否能改变这一点时，对于没有训练数据的真正新颖问题，回答是怀疑的。在这些情况下，人工智能模型尚不具备真正的创造力；例如，为全新的芯片架构编写驱动程序仍将主要是一项手动任务。幸运的是，这仅占所有软件开发的极小部分（例如
0.01%）。对于绝大多数任务，如实施另一个 ERP
系统，由于存在大量训练数据，这些工具可以非常强大。



## "Vibe Coding" and Democratization of Software Development / “感觉式编程”与软件开发的民主化

<div class="section-en">

The concept of "vibe coding"—people who are not developers writing
code—was discussed as a positive development, likening it to a
democratization where ordinary people can control computers more
directly, rather than needing "priests of the computer" (traditional
developers) to intervene. This raises the question of scale: can
everyone build a digital "shack," but not a "skyscraper"? The optimism
is that if some portion of these new coders climb the ladder and create
sophisticated things in novel ways, it could lead to new applications
and new ways of using computers. This was compared to the rise of
blogging in the 2000s, where tools like WordPress enabled widespread
content creation. "Vibe coding" feels similar, with people creating
personal software (e.g., personal CRMs). The depth of such software
might be limited, but personal utility is key. Martin Kleppmann's tweet
about needing to learn the abstraction layer below where one operates
was cited, leading to the question of what the lower abstraction is for
vibe coders: is it code, the IDE, or something else?



<div class="section-zh">

讨论了“感觉式编程”（vibe
coding）的概念——即非开发者编写代码——认为这是一种积极的进展，将其比作一种民主化，普通人可以更直接地控制计算机，而不再需要“计算机的祭司”（传统开发者）介入。这就引出了一个规模问题：是否每个人都能建造数字化的“小屋”，但建不了“摩天大楼”？乐观的看法是，如果这些新晋编码者中的一部分能够不断进步，并以新颖的方式创造出复杂的事物，就可能带来新的应用和新的计算机使用方式。这被比作
2000 年代博客的兴起，当时像 WordPress
这样的工具使得内容创作得以普及。“感觉式编程”感觉类似，人们创建个人软件（例如，个人
CRM）。这类软件的深度可能有限，但个人效用是关键。Martin Kleppmann
关于需要学习操作层面之下的抽象层的推文被引用，引出了一个问题：对于感觉式编码者来说，更底层的抽象是什么？是代码、IDE，还是其他东西？



## The Future of Computer Science Education / 计算机科学教育的未来

<div class="section-en">

The question of what future software developers need to learn is
critical. Some argue there is no point in learning CS anymore, focusing
instead on social-emotional learning, though this view was met with
skepticism. The speaker admitted having no idea what CS education will
look like in five years. Historically, when calculation shifted from
manual methods to tools like Excel, the job category of bookkeepers
evolved into accountants; data entry became less important, while
higher-level abstract concepts gained prominence. By analogy, explaining
problem statements, algorithmic foundations, architecture, and data flow
might become more important than a nitty-gritty coding, like optimizing
a for-loop, which could become a niche skill.

It feels like we are waiting for something. Classical CS education often
teaches foundational concepts like assembly language, processor
architecture, Lisp, file systems, and operating systems—not just the
latest tools. Java was once state-of-the-art. It is tempting to see AI
as the next layer built on these, with traditional coding learned for
historical or educational reasons. However, it is not yet clear if this
is true. Previous layers added over decades were new programming
interfaces. AI is not yet a programming interface or framework in the
same way; it is a tool that helps use existing things. This prompts
wonder about the next iteration: something AI can fundamentally change
about how computers are programmed, perhaps prompts translated more
directly to code, with current agents as a starting point.



<div class="section-zh">

未来软件开发者需要学习什么是一个关键问题。一些人认为不再有学习计算机科学的必要，而应专注于社交情感学习，尽管这种观点受到了质疑。发言者承认不知道五年后计算机科学教育会是什么样子。从历史上看，当计算从手动方法转向像
Excel
这样的工具时，簿记员这一职业类别演变成了会计师；数据录入变得不那么重要，而更高级别的抽象概念变得更加突出。以此类推，解释问题陈述、算法基础、架构和数据流可能会变得比具体的编码细节（如优化
for 循环）更重要，后者可能成为一项小众技能。

感觉我们正在等待着什么。经典的计算机科学教育通常教授基础概念，如汇编语言、处理器架构、Lisp、文件系统和操作系统——而不仅仅是最新的工具。Java
曾是最先进的技术。人们很容易将人工智能视为建立在这些基础之上的下一层，而传统编码的学习则出于历史或教育原因。然而，目前尚不清楚这是否属实。过去几十年中添加的层是新的编程接口。人工智能目前还不是同样意义上的编程接口或框架；它是一个帮助使用现有事物的工具。这引发了对下一次迭代的思考：人工智能可能会从根本上改变计算机编程方式的某些东西，也许是提示更直接地翻译成代码，而当前的代理则是起点。



## AI as a Higher-Level Abstraction or Compiler Tool / 人工智能作为更高级别的抽象或编译器工具

<div class="section-en">

One speaker believes AI could become a higher-level language abstraction
over time. Reflecting on classic compiler design, if LLMs were a tool,
one would think very differently about building a compiler. While the
exact future form is unknown, if certain things can be defined in human
language efficiently and tightly enough to be used as direct compiler
input, it could change a lot. An analogy was drawn: many companies are
building agent-based systems that, upon inspection, resemble concepts
from operating systems classes (processes, forking, task handling,
resource management). Without CS education, one might not even recognize
these patterns. Formal languages exist for a reason—they provide a
high-bandwidth, expressive way to design software. It is hard to see
programming languages like Python disappearing entirely. The need to
understand at least one level of abstraction down remains. Python and
JavaScript are currently leading, partly due to active tooling
ecosystems, which impacts how well they integrate with AI add-ons. These
foundational elements cannot be discarded.



<div class="section-zh">

一位发言者认为，随着时间的推移，人工智能可能成为一种更高级别的语言抽象。回顾经典的编译器设计，如果大型语言模型是一种工具，那么人们在构建编译器时会有截然不同的思路。虽然未来的确切形式尚不清楚，但如果某些事物能够以高效且足够严谨的人类语言进行定义，并用作直接的编译器输入，那可能会改变很多事情。有人打了个比方：许多公司正在构建基于代理的系统，仔细观察后会发现，这些系统与操作系统课程中的概念（进程、派生、任务处理、资源管理）相似。如果没有计算机科学教育背景，人们甚至可能无法识别这些模式。形式语言的存在是有原因的——它们提供了一种高带宽、富有表现力的方式来设计软件。很难想象像
Python
这样的编程语言会完全消失。至少需要理解下一层抽象的需求依然存在。Python
和 JavaScript
目前处于领先地位，部分原因是其活跃的工具生态系统，这影响了它们与人工智能附加组件的集成程度。这些基础元素不容丢弃。



## The Need for Understanding Underlying Systems / 理解底层系统的必要性

<div class="section-en">

The reason to know a deeper abstraction level is for system
optimization. If optimization is not needed, then deeper knowledge may
not be necessary (e.g., someone creating a simple Java calculator might
not need to understand the JVM). However, for optimizing runtime
threading, JVM knowledge is crucial. Similarly, for "vibe coding," if
building a simple marketing website, deep optimization knowledge is not
needed. But for serving something at scale, understanding CDNs, page
caching, etc., becomes essential. To build and scale a real service, it
is hard to avoid knowing the underlying "knobs" because computers
operate based on formal languages, layered upon each other. Accessing
these knobs requires understanding these languages.

Guido agreed that formal languages would not disappear, as they are
often the simplest representation to specify intent. Natural language is
often imprecise and requires more words for the same result. The
interesting question is whether AI, with enough human understanding
context and context from user inputs (e.g., "@" symbols pulling in
pages), can accurately translate natural language descriptions for a
subset of problems. This seems possible in areas where AI is already
used for coding. The potential for hybridizing this into a new type of
language was pondered.



<div class="section-zh">

了解更深层次抽象的原因在于系统优化。如果不需要优化，那么更深层次的知识可能就不是必需的（例如，创建一个简单的
Java 计算器的人可能不需要了解 JVM）。然而，为了优化运行时线程，JVM
知识至关重要。同样，对于“感觉式编程”，如果只是构建一个简单的营销网站，则不需要深入的优化知识。但如果要大规模提供服务，了解
CDN、页面缓存等就变得至关重要。要构建和扩展真正的服务，很难避免了解底层的“旋钮”，因为计算机是基于相互层叠的形式语言运行的。要操作这些旋钮，就需要理解这些语言。

Guido
同意形式语言不会消失，因为它们通常是指定意图的最简单表示。自然语言通常不精确，需要更多词语才能达到相同的结果。有趣的问题是，人工智能在拥有足够的人类理解上下文和用户输入上下文（例如，通过“@”符号引入页面）的情况下，是否能够准确翻译某些问题的自然语言描述。在人工智能已经用于编码的领域，这似乎是可能的。与会者思考了将此混合成一种新型语言的潜力。



## Complexity: AI vs. Formal Languages / 复杂性：人工智能与形式语言

<div class="section-en">

A distinction was made regarding the word "complicated." Programming
languages might seem hard to learn (complicated to use) but are
structurally simple (their entire expressive range can be mapped). AI
coding, while easier to use, is vastly more complicated under the hood.
This raises the question of how to manage this: a hybrid solution or
something else? The Cursor team's focus on formal specifications was
mentioned, aligning with Guido's point about clear spec writing becoming
increasingly important—an "annealing process" between human and AI to
reach a tight, implementable spec from loosely formed ideas.

Yoko shared an anecdote about a "vibe coder" who liked seeing AI
generate code, finding it empowering, but did not know where to start
when wanting to modify it. This highlights a gap between AI-generated
code and the operational level of vibe coders, suggesting a product
opportunity to empower them to change underlying knobs. This opacity is
not restricted to inexperienced programmers; even experienced ones would
find it difficult to edit AI-generated code after several iterations.

Yoko further illustrated this with her experience using a Blender MCP.
She could easily prompt a mini-statue of "a16z infra" but struggled when
trying to modify the 3D representation, not knowing where to start or
why a flat surface had 10,000 polygons. This indicates many
opportunities in the gaps between AI, vibe coders, and current
representations.



<div class="section-zh">

对于“复杂”一词的含义进行了区分。编程语言可能看起来难以学习（使用复杂），但在结构上很简单（其全部表达范围都可以映射出来）。人工智能编码虽然更易于使用，但其底层却要复杂得多。这就提出了如何管理这个问题：是混合解决方案还是其他方案？提到了
Cursor 团队对形式规范的关注，这与 Guido
关于清晰规范编写日益重要的观点相一致——这是一个介于人类和人工智能之间的“退火过程”，从松散形成的想法到最终可实现的严谨规范。

Yoko
分享了一个关于“感觉式编码者”的轶事，这位编码者喜欢看到人工智能生成代码，觉得这赋予了他力量，但在想要修改代码时却不知从何入手。这突显了人工智能生成的代码与感觉式编码者操作层面之间的差距，表明存在一个产品机会，可以赋予他们改变底层“旋钮”的能力。这种不透明性并不仅限于缺乏经验的程序员；即使是经验丰富的程序员，在经过几次迭代后，也会发现编辑人工智能生成的代码非常困难。

Yoko 用她使用 Blender MCP
的经历进一步说明了这一点。她可以轻松地提示生成一个“a16z
infra”的迷你雕像，但在尝试修改这个 3D
表示时却遇到了困难，不知道从何开始，也不知道为什么一个平面会有 10,000
个多边形。这表明在人工智能、感觉式编码者和当前表示之间的空白中存在许多机会。



## AI, Legacy Code, and Capturing Intent / 人工智能、遗留代码与捕捉意图

<div class="section-en">

A new layer of context and intent in software programming is being
created. The question of whether AI can help port old code (e.g., COBOL
from banks) was addressed. The consensus was that AI can help but not
solve the hard problem entirely. AI might transpile COBOL to Java, but
the vast context and original intent behind the COBOL code (often lost
over decades, with undocumented changes and departed developers) are
missing. However, if AI had been used to create those systems
originally, there would be an additional record of intent, a form of
metadata capturing software intent differently. This is a cool aspect of
current AI adoption: this "other set of metadata" comes for free.

Guido confirmed this, sharing conversations with large enterprises using
AI to migrate legacy mainframe code (COBOL, PL/1) to modern languages.
They face the issue that direct translation often carries over
idiosyncrasies of the old language. The most efficient approach they
found is to first use AI to create a spec from the old code, and then
reimplement that spec. This yields much better, more compact, and modern
code. This is an AI-assisted process for both spec creation and
reimplementation.

Yoko added that rewriting modern software (e.g., Angular to React) is
easier, especially if both frameworks are well understood by the agent.
Migrating PHP (e.g., Laravel) to Angular can also be manageable. It
becomes much harder if the state spans many systems, requiring discovery
capabilities, or if there are hardware-specific configurations that are
lost over time. Until runtime snapshots can capture all requirements,
migrating such systems remains difficult.



<div class="section-zh">

软件编程中正在创建一个新的上下文和意图层面。讨论了人工智能是否能帮助移植旧代码（例如，银行的
COBOL
代码）的问题。普遍的看法是，人工智能可以提供帮助，但不能完全解决这个难题。人工智能或许可以将
COBOL 代码转换为 Java 代码，但 COBOL
代码背后的大量上下文和原始意图（通常在数十年间丢失，伴随着未记录的更改和离职的开发人员）却缺失了。然而，如果当初使用人工智能来创建这些系统，就会有额外的意图记录，这是一种以不同方式捕捉软件意图的元数据。这是当前人工智能应用的一个很酷的方面：这套“额外的元数据”是免费获得的。

Guido
证实了这一点，分享了他与大型企业的对话，这些企业正在使用人工智能将遗留的大型机代码（COBOL、PL/1）迁移到现代语言。他们面临的问题是，直接翻译通常会保留旧语言的特性。他们发现最有效的方法是首先使用人工智能从旧代码中创建规范，然后重新实现该规范。这样可以产生更好、更紧凑、更现代的代码。这在规范创建和重新实现两个方面都是一个有人工智能辅助的过程。

Yoko 补充说，重写现代软件（例如，从 Angular 到
React）更容易，特别是如果代理对两个框架都有很好的理解。将 PHP（例如
Laravel）迁移到 Angular
也是可以处理的。如果状态跨越许多系统，需要发现能力，或者存在随时间丢失的特定于硬件的配置，那么迁移就会变得困难得多。在运行时快照能够捕获所有需求之前，迁移此类系统仍然很困难。



## AI as a Primitive: Uncertainty and Non-Determinism / 人工智能作为基本要素：不确定性与非确定性

<div class="section-en">

The conversation shifted to AI as a primitive in an application, not
just a coding tool. This seems to push the frontiers of uncertainty and
non-deterministic behavior in software. Early software for local
machines had predictable execution. The network introduced
unpredictability (timeouts, etc.), leading to remedies like retries and
complex distributed database concepts (atomicity, rollbacks). Some of
these design patterns are still not perfectly architected. AI feels like
an extension of this. While models at temperature zero are technically
deterministic, an infinitesimally small change in input can have an
arbitrarily large effect, making them chaotic systems. Users can input
anything, and the system's chaotic nature means almost anything can
happen—far beyond just checking for apostrophes to prevent SQL
injection. The phrase "Ignore all previous instructions" exemplifies
this. It was suggested that perhaps the focus should be on exposing
primitives and capabilities for developers to use, rather than trying to
suppress all failure modes, similar to how networking primitives were
exposed.

One large bank, when implementing AI for text generation, faced the
challenge of preventing investment advice. They concluded it is an
unsolvable problem to guarantee an LLM never gives such advice, even
implicitly. Adding a second LLM to catch it also is not foolproof. They
ultimately changed their metrics, aiming for the AI to have, for
example, half the probability of a well-trained human making the same
mistake.



<div class="section-zh">

对话转向将人工智能视为应用程序中的一个基本要素，而不仅仅是一个编码工具。这似乎正在推动软件中不确定性和非确定性行为的边界。早期的本地机器软件具有可预测的执行。网络引入了不可预测性（超时等），从而产生了诸如重试和复杂的分布式数据库概念（原子性、回滚）等补救措施。其中一些设计模式至今仍未得到完美的架构。人工智能感觉像是这种趋势的延伸。虽然温度为零的模型在技术上是确定性的，但输入中极小的变化可能会产生任意大的影响，使其成为混沌系统。用户可以输入任何内容，而系统的混沌特性意味着几乎任何事情都可能发生——这远不止于仅仅检查撇号以防止
SQL
注入。“忽略所有先前的指令”这句话就是例证。有人建议，或许重点应该放在向开发者暴露基本要素和能力供其使用，而不是试图抑制所有故障模式，类似于网络基本要素的暴露方式。

一家大型银行在实施用于文本生成的人工智能时，面临着防止提供投资建议的挑战。他们得出结论，要保证大型语言模型永远不提供此类建议（即使是隐含的）是一个无法解决的问题。添加第二个大型语言模型来捕获它也并非万无一失。他们最终改变了衡量标准，目标是例如，让人工智能犯同样错误的概率是训练有素的人类的一半。



## The "Narrow Waist" of AI: Prompts and Formalization / 人工智能的“窄腰”：提示与形式化

<div class="section-en">

Drawing an analogy to the internet's "narrow waist" (IP protocol), the
question arose if a similar dynamic would play out in AI. One speaker
suggested the prompt is AI's narrow waist. Big tech cycles are often
built on abstractions that encapsulate underlying complexity in a narrow
API (e.g., SQL for databases). This enabled the rise of modern ML, where
a mediocre Python programmer can leverage powerful LLMs via prompting,
without needing an "overpaid Stanford PhD" to train models. When asked
if prompts are natural language or something else, as there is no
standard, it was noted that prompts are not strictly formal languages,
but also not plain English; users are learning a new "language" to
prompt models, with dialects for different models. The possibility of a
formal prompting language was raised, with some "overpriced Stanford
PhDs" likely working on it. Agent frameworks were considered a little
bit like formal prompting languages, as they introduce structure (e.g.,
user/agent tags, JSON mode). Models are already being trained on more
structured representations, like defining desired JSON output via a type
system. It was speculated that future reasoning models might have a
separate output layer for user-facing or machine-facing generation,
distinct from the internal reasoning layer, allowing for different
output styles (chatty, terse, JSON) from the same core reasoning.



<div class="section-zh">

借鉴互联网“窄腰”（IP协议）的类比，有人提出了一个问题：类似的动态是否会在人工智能领域上演。一位发言者认为，提示（prompt）是人工智能的窄腰。大型科技周期通常建立在抽象之上，这些抽象通过狭窄的
API（例如数据库的
SQL）封装了底层的复杂性。这推动了现代机器学习的兴起，使得一个普通的
Python
程序员可以通过提示来利用强大的大型语言模型，而无需“薪酬过高的斯坦福博士”来训练模型。当被问及提示是自然语言还是其他什么，因为没有标准时，有人指出提示并非严格的形式语言，但也并非纯粹的英语；用户正在学习一种新的“语言”来提示模型，不同模型还有各自的“方言”。有人提出了形式化提示语言的可能性，并提到一些“薪酬过高的斯坦福博士”可能正在研究这个问题。代理框架被认为有点像形式化的提示语言，因为它们引入了结构（例如，用户/代理标签、JSON
模式）。模型已经在基于更结构化的表示进行训练，例如通过类型系统定义所需的
JSON
输出。有人推测，未来的推理模型可能会有一个独立的输出层，用于面向用户或面向机器的生成，与内部推理层分开，从而允许从同一核心推理中产生不同的输出风格（健谈的、简洁的、JSON格式的）。



## Vibe Coding vs. Enterprise Coding Models / 感觉式编程与企业级编码模型

<div class="section-en">

Finally, the question of whether there will be different models for
"vibe coding" versus enterprise coding was posed. Yoko expressed a
belief that there would not be a fundamental difference. She defined
vibe coding as letting the model generate implementations based on a
spec without concern for implementation details, as long as the output
meets the high-level needs. Classical coding, in contrast, involves more
explicit choices about SDKs and other specifics. She could envision
enterprise users engaging in vibe coding, viewing it as a compliment to
their existing processes if it efficiently gets things done according to
higher-level requirements.



<div class="section-zh">

最后，有人提出了一个问题：“感觉式编程”与企业级编码是否会使用不同的模型。Yoko
表示她认为两者之间不会有根本区别。她将感觉式编程定义为：根据规范让模型生成实现，而不关心实现细节，只要输出满足高层需求即可。相比之下，经典编码涉及更多关于
SDK
和其他具体细节的明确选择。她可以想象企业用户进行感觉式编程，如果这种方式能够根据高层需求高效地完成任务，那么它将成为对现有流程的一种补充。



<div class="copy-button-container">

一键复制为Markdown
